/*! For license information please see chunk.1754b0893ec082643123.js.LICENSE.txt */
"use strict";(self.webpackChunkai_workout_assistant=self.webpackChunkai_workout_assistant||[]).push([[308],{38483:(e,n,t)=>{t.d(n,{Z:()=>u,j:()=>s});var o=t(36115),r=t(15411),i=t(76905);const a="return a - b;",s=(0,r.j0)({opSnippet:a,packedOpSnippet:a,supportsComplex:!0,cpuKernelImpl:i.lL}),u={kernelName:o.PbM,backendName:"webgl",kernelFunc:s}},22853:(e,n,t)=>{t.d(n,{c:()=>s,q:()=>u});var o=t(36115),r=t(68754),i=t(43008),a=t(89523);function s(e){const{inputs:n,backend:t,attrs:s}=e,{x:u}=n,{axis:c,keepDims:l}=s;return function(e,n,t,s){const u=n,c=e.shape.length,l=o.ZSL.parseAxisParam(u,e.shape);let d=l;const h=o.backend_util.getAxesPermutation(d,c),p=null!=h;let f=e;p&&(f=(0,a._)(e,h,s),d=o.backend_util.getInnerMostAxes(d.length,c)),o.backend_util.assertAxesAreInnerMostDims("sum",d,c);const[x,$]=o.backend_util.computeOutAndReduceShapes(f.shape,d);let v=x;t&&(v=o.backend_util.expandShapeToKeepDim(x,l));const g=o.ZSL.sizeFromShape($),C=o.ZSL.sizeFromShape(e.shape)/g,m=(0,i.t)({inputs:{x:f},attrs:{shape:[C,g]},backend:s}),R=(0,o.chL)(e.dtype),b=(0,r.T)(m,R,"sum",s),S=(0,i.t)({inputs:{x:b},attrs:{shape:v},backend:s});return s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(b),p&&s.disposeIntermediateTensorInfo(f),S}(u,c,l,t)}const u={kernelName:o.WuN,backendName:"webgl",kernelFunc:s}},58246:(e,n,t)=>{t.d(n,{W:()=>s,m:()=>a});var o=t(36115),r=t(89523),i=t(76905);function a(e){const{inputs:n,backend:t,attrs:o}=e,{x:a}=n,{perm:s}=o,u=t,c=a.shape.length,l=new Array(c);for(let e=0;e<l.length;e++)l[e]=a.shape[s[e]];let d;if(u.shouldExecuteOnCPU([a])){const e=u.texData.get(a.dataId).values,n=(0,i.Q5)(e,a.shape,a.dtype,s,l);d=u.makeTensorInfo(l,a.dtype),u.texData.get(d.dataId).values=n}else d=(0,r._)(a,s,u);return d}const s={kernelName:o.wx0,backendName:"webgl",kernelFunc:a}},89523:(e,n,t)=>{t.d(n,{_:()=>u});var o=t(36115),r=t(27575);class i{constructor(e,n){this.variableNames=["A"];const t=new Array(e.length);for(let o=0;o<t.length;o++)t[o]=e[n[o]];this.outputShape=t,this.rank=t.length;const o=(0,r.bf)(this.rank),i=function(e){const n=e.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],o=new Array(n);for(let n=0;n<e.length;n++)o[e[n]]=t[n];return o.join()}(n);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}var a=t(75694);class s{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const t=new Array(e.length);for(let o=0;o<t.length;o++)t[o]=e[n[o]];if(this.outputShape=t,this.rank=t.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const o=(0,r.bf)(this.rank),i=(0,a.Fd)("rc",this.rank),s=new Array(this.rank);for(let e=0;e<n.length;e++)s[n[e]]=i[e];const u=`vec2(${s.slice(-2).join()})`,c=`++${i[this.rank-1]} < ${t[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${u})`;this.userCode=`\n    void main() {\n      ${o} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${c}) {\n        result[1] = ${l};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${t[this.rank-2]}) {\n        result[2] = ${l};\n        if(${c}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function u(e,n,t){const r=(0,o._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new s(e.shape,n):new i(e.shape,n);return t.runWebGLProgram(r,[e],e.dtype)}},30097:(e,n,t)=>{t.d(n,{P:()=>u,Z:()=>c});var o=t(36115),r=t(8993),i=t(37664),a=t(39803),s=t(4313);function u(e){const{inputs:n,backend:t}=e,{x:o}=n;if("complex64"===o.dtype){const e=(0,s.x)({inputs:{input:o},backend:t}),n=u({inputs:{x:e},backend:t}),i=(0,a.n)({inputs:{input:o},backend:t}),c=u({inputs:{x:i},backend:t}),l=(0,r.f)({inputs:{real:n,imag:c},backend:t});return t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),l}return(0,i.G)({attrs:{shape:o.shape,dtype:o.dtype,value:"string"===o.dtype?"":0},backend:t})}const c={kernelName:o.xJ3,backendName:"webgl",kernelFunc:u}},66501:(e,n,t)=>{t.d(n,{F:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["x"],this.outputShape=[];const i=n,a=e[3]-1;let s;this.outputShape=e;const u=`float(${t}) + float(${o}) * sum`;s=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${s};\n        setOutput(val);\n      }\n    `}}},96146:(e,n,t)=>{t.d(n,{j:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=t,this.alpha=o,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${n})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${n} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${o}) * norm + float(${t});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${o})\n                * float(${r})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}},19314:(e,n,t)=>{t.d(n,{f:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,a=e[3]-1;let s;this.outputShape=e;const u=`float(${t}) + float(${o}) * sum`;s=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `}}},81017:(e,n,t)=>{t.d(n,{Y:()=>r,d:()=>o});class o{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,t=e.strideWidth,o=e.dilationHeight,r=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=r-1-e.padInfo.top,s=i-1-e.padInfo.left,u=r*i-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${n}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class r{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,t=e.strideHeight,o=e.strideWidth,r=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,s=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=s-1-e.padInfo.front,d=u-1-e.padInfo.top,h=c-1-e.padInfo.left,p=s*u*c-1;this.userCode=`\n      const ivec3 pads = ivec3(${l}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${n}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${t}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},89486:(e,n,t)=>{t.d(n,{C:()=>r});var o=t(36115);class r{constructor(e,n){this.variableNames=["x"];const{windowSize:t,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];const s=4*Math.floor(t/4),u=t%4;let c="sumValue += dot(values, ones);";if(null!=n){const e=1/n;c=`sumValue += dot(values * ${o.ZSL.isInt(e)?e.toPrecision(2):e}, ones);`}let l="";i%t>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${t};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}},51554:(e,n,t)=>{t.d(n,{X:()=>r});var o=t(27575);class r{constructor(e,n,t){this.variableNames=["x"],this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const r=e.length,i=(0,o.bf)(r),a=n.map((e=>e[0])).join(","),s=n.map(((n,t)=>n[0]+e[t])).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c="reflect"===t?0:1;this.userCode=1!==r?`\n      ${i} start = ${i}(${a});\n      ${i} end = ${i}(${s});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${u}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}},2171:(e,n,t)=>{t.d(n,{V:()=>i});var o=t(75694),r=t(27575);class i{constructor(e,n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const i=e.length,a=(0,r.bf)(i),s=n.map((e=>e[0])).join(","),u=n.map(((n,t)=>n[0]+e[t])).join(","),c=(0,o.Jp)("rc",i),l=(0,o.Jp)("source",i),d=`${c[i-1]} < ${this.outputShape[i-1]}`,h=1===i?"source":`vec2(${l.slice(-2).join()})`,p="reflect"===t?0:1;let f="";if(1===i){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${p};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${p};\n        }\n        source -= start;\n      `;f=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${h});\n        ${c[i-1]} += 1;\n        if(${d}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${h});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${p}) +\n                gte * ((end - 1) * 2 - source + ${p});\n        source -= start;\n      `;f=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${h});\n        ${c[i-1]} += 1;\n        if(${d}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${h});\n        }\n        rc = outputLoc;\n        ${c[i-2]} += 1;\n        if(${c[i-2]} < ${this.outputShape[i-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${h});\n          ${c[i-1]} += 1;\n          if(${d}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${h});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${u});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}},63288:(e,n,t)=>{t.d(n,{P:()=>r});var o=t(22792);class r{constructor(e,n,t,r=!1,i=!1,a=!1,s=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=(0,o.ik)(this.outputShape.length);const l=r?e[1]:e[2],d=Math.ceil(l/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let $="",v="";s&&($=u?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,v="result = activation(result);");const g=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let C="rc.x",m="rc.x";e[0]<n[0]?C=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(m=`imod(rc.x, ${n[0]})`),this.userCode=`\n      ${$}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${C};\n        int batchB = ${m};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${x[0]});\n          result += (${f[1]} * ${x[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${v}\n\n        setOutput(result);\n      }\n    `}}},26608:(e,n,t)=>{t.d(n,{O:()=>o});class o{constructor(e,n,t){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${n-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${n-1}));\n      }\n    `}}},94804:(e,n,t)=>{t.d(n,{M:()=>o});class o{constructor(e,n,t,o){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${o}), float(${t}),\n                      float(index == coords.y)));\n      }\n    `}}},30282:(e,n,t)=>{t.d(n,{m:()=>a});var o=t(22792),r=t(75694),i=t(27575);class a{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=(0,o.ik)(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=(0,r.Jp)("rc",this.rank),n=(0,i.bf)(this.rank),t=this.getOutOfBoundsCondition(e),o=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${t}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const n=[];for(let t=0;t<=1;t++)for(let o=0;o<=1;o++){let r=`${0===t?"r":"rp1"}, ${0===o?"c":"cp1"}`;for(let n=2;n<this.rank;n++)r=`${e[e.length-1-n]},`+r;n.push(r)}return n}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let t=this.rank-2;t<this.rank;t++)n+=`${e[t]} >= ${this.enableShapeUniforms?`outShape[${t}]`:this.outputShape[t]}`,t<this.rank-1&&(n+="||");return n}getSetup(e){if(1===this.rank)return"";const n=e.slice(-2),t=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${n[0]};\n      int c = ${n[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${t};\n      bool rEdge = rp1 >= ${o};\n    `}getOutput(e){const n=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),\n            cEdge ? 0. : getA(${n[1]}),\n            rEdge ? 0. : getA(${n[2]}),\n            rEdge || cEdge ? 0. : getA(${n[3]})`}}},75694:(e,n,t)=>{function o(e,n){return["x","y","z","w","u","v"].slice(0,n).map((n=>`${e}.${n}`))}function r(e,n){return 1===n?[e]:o(e,n)}function i(e,n){if(1===e)return"rc";let t="";for(let o=0;o<e;o++)t+=n[o],o<e-1&&(t+=",");return t}t.d(n,{Fd:()=>o,Jp:()=>r,kp:()=>i})},59344:(e,n,t)=>{t.d(n,{e:()=>r});var o=t(27575);class r{constructor(e,n,t){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const r=e.length,i=(0,o.bf)(r),a=n.map((e=>e[0])).join(","),s=n.map(((n,t)=>n[0]+e[t])).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${a});\n      ${i} end = ${i}(${s});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${u}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}},11601:(e,n,t)=>{t.d(n,{_:()=>i});var o=t(75694),r=t(27575);class i{constructor(e,n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const i=e.length,a=(0,r.bf)(i),s=n.map((e=>e[0])).join(","),u=n.map(((n,t)=>n[0]+e[t])).join(","),c=(0,o.Jp)("rc",i),l=(0,o.Jp)("source",i),d=`${c[i-1]} < ${this.outputShape[i-1]}`,h=1===i?"source":`vec2(${l.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${c[i-1]} += 1;\n       if(${d}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${c[i-2]} += 1;\n       if(${c[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${c[i-1]} += 1;\n         if(${d}) {`],f=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let e=0,n=1===i?2:4;e<n;e++)x+=`\n        ${p[e]}\n        if (${f}) {\n          result[${e}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${h});\n        }\n      `;x+=1===i?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${u});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}},80297:(e,n,t)=>{t.d(n,{U:()=>r,h:()=>o});class o{constructor(e,n,t,o=!1,r=!1){if(this.variableNames=["x"],"avg"===n&&t)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===n,x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,$=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let v="0.0";if(f||(v="-1.0 / 1e-20"),t){const n=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${s});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${n} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${o?r?x:$:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let g=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===n&&(g="avgValue / max(count, 1.0)");const C=4*Math.floor(i/4),m=i%4,R=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${C};\n          if (${1===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${2===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class r{constructor(e,n,t,o=!1,r=!1){if(this.variableNames=["x"],"avg"===n&&t)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,s=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,$=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const g="avg"===n;let C="0.0";if(g||(C="-1.0 / 1e-20"),t){const n=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${s}, ${u});\n        const ivec3 pads = ivec3(${x}, ${$}, ${v});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${n} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${o?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let m=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===n&&(m="avgValue / max(count, 1.0)");const R=4*Math.floor(i/4),b=i%4,S=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${s}, ${u});\n      const ivec3 pads = ivec3(${x}, ${$}, ${v});\n      const float initializationValue = ${C};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${C});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${R}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${R};\n            if (${1===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${m});\n      }\n    `}}},18541:(e,n,t)=>{t.d(n,{t:()=>o});class o{constructor(e,n){this.variableNames=["x"];const{windowSize:t,batchSize:o,inSize:r,outSize:i}=e;this.outputShape=[o,i];let a="0.0",s="";"prod"===n?a="1.0":"min"===n?(a="1.0 / 1e-20",s="min"):"max"===n&&(a="-1.0 / 1e-20",s="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===n?u="sumValue":"prod"===n?u="prodValue":"all"===n?u="allValue":"any"===n&&(u="anyValue");const c=4*Math.floor(t/4),l=t%4;let d=`\n      if (${"sum"===n}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===n}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${s}(values, minMaxValue);\n        if (${"min"===n} || ${"max"===n}) {\n          minMaxValue = ${s}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===n?(a="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===n&&(a="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";r%t>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${t};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===l}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===l}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===l}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}},74479:(e,n,t)=>{var o=t(36115),r=t(64374);const i={kernelName:o.Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{a:i,b:a,bias:s,preluActivationWeights:u}=n,{transposeA:c,transposeB:l,activation:d,leakyreluAlpha:h}=o;return(0,r.L)({a:i,b:a,transposeA:c,transposeB:l,backend:t,bias:s,preluActivationWeights:u,leakyreluAlpha:h,activation:d})}};var a=t(65253),s=t(32019),u=t(92619),c=t(8982),l=t(40154),d=t(63990),h=t(72335),p=t(45247),f=t(90085),x=t(1806),$=t(73844),v=t(25007),g=t(37913),C=t(97743),m=t(21119),R=t(78060),b=t(83312),S=t(84631),T=t(8537),y=t(82339),w=t(65514),I=t(72517),k=t(36951),E=t(46227),F=t(35960),O=t(47357),A=t(8993),N=t(37053),V=t(93179),_=t(66045),D=t(91241),U=t(4879),L=t(14992),M=t(7664),z=t(94948),P=t(15354),B=t(86856),X=t(16998),W=t(97591),j=t(5171),G=t(99590),H=t(46355),K=t(14947),Z=t(86099),Y=t(48689),q=t(7530),J=t(31345),Q=t(72718),ee=t(46321),ne=t(93057),te=t(73525),oe=t(83910),re=t(29450),ie=t(98134),ae=t(70324),se=t(89805),ue=t(37664),ce=t(99893),le=t(54087),de=t(15328),he=t(16386),pe=t(39882),fe=t(65057),xe=t(66900),$e=t(23706),ve=t(95171),ge=t(379),Ce=t(77723),me=t(66696),Re=t(39803),be=t(83834),Se=t(95442),Te=t(3872),ye=t(66921),we=t(26132),Ie=t(4094),ke=t(22970),Ee=t(71739),Fe=t(12462),Oe=t(57133),Ae=t(4873),Ne=t(10695),Ve=t(6489),_e=t(89193),De=t(99160),Ue=t(23007),Le=t(18801),Me=t(92914),ze=t(65886),Pe=t(17249),Be=t(38717),Xe=t(52132),We=t(69941),je=t(25621),Ge=t(94449),He=t(19013),Ke=t(89488),Ze=t(26041),Ye=t(40279),qe=t(73816),Je=t(14669),Qe=t(70318),en=t(98890),nn=t(62642),tn=t(64635),on=t(54532),rn=t(92616),an=t(48223),sn=t(14899),un=t(74952),cn=t(73008),ln=t(53874),dn=t(67926),hn=t(39264),pn=t(4313),fn=t(4490),xn=t(49649),$n=t(37647),vn=t(14421),gn=t(43008),Cn=t(2249),mn=t(68889),Rn=t(43137),bn=t(96017),Sn=t(86567),Tn=t(24929),yn=t(84745),wn=t(34733),In=t(35137),kn=t(33556),En=t(51361),Fn=t(64770),On=t(24129),An=t(43168),Nn=t(60739),Vn=t(49627),_n=t(29547),Dn=t(62667),Un=t(68065),Ln=t(50894),Mn=t(49442),zn=t(25103),Pn=t(58137),Bn=t(40257),Xn=t(80809),Wn=t(63575),jn=t(5643),Gn=t(12030),Hn=t(55571),Kn=t(68173);const Zn={kernelName:o.pnw,backendName:"webgl",kernelFunc:function({inputs:e,attrs:n,backend:t}){const{x:o}=e,r=Kn.dR+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new Kn.hE(o.shape,r);return t.runWebGLProgram(i,[o],o.dtype)}};var Yn=t(76905),qn=t(27575);class Jn{constructor(e,n,t){this.variableNames=["x"],this.outputShape=t;const o=t.length,r=(0,qn.bf)(t.length),i=(0,qn.bf)(t.length);let a="";if(1===o)a="coords * strides + begin";else{let e=0;a=t.map(((n,o)=>(e++,1===t.length?`coords * strides[${o}] + begin[${o}]`:`coords[${e-1}] * strides[${o}] + begin[${o}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${n});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const Qn={kernelName:o.UcO,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:i}=n,{begin:a,end:s,strides:u,beginMask:c,endMask:l,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:x,isIdentity:$,sliceDim0:v,isSimpleSlice:g,begin:C,end:m,strides:R}=o.Kro.sliceInfo(i.shape,a,s,u,c,l,d,h,p);let b;if($)b=(0,gn.t)({inputs:{x:i},backend:t,attrs:{shape:x}});else if(v||g){o.ZSL.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const e=o.Kro.computeOutShape(C,m,R),n=(0,_n.d)({inputs:{x:i},backend:t,attrs:{begin:C,size:e}});b=(0,gn.t)({inputs:{x:n},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(n)}else if(t.shouldExecuteOnCPU([i])){const e=t.readSync(i.dataId),n=(0,o.ra8)(i.shape,i.dtype,e),r=(0,Yn.cy)(f,n,R,C);b=t.makeTensorInfo(x,i.dtype,r.values)}else{const e=new Jn(C,R,f);b=t.runWebGLProgram(e,[i],i.dtype)}const S=(0,gn.t)({inputs:{x:b},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(b),S}},et={kernelName:o.YAb,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{separator:r,nGramWidths:i,leftPad:a,rightPad:s,padWidth:u,preserveShortSequences:c}=o,{data:l,dataSplits:d}=n,h=t.readSync(l.dataId),p=t.readSync(d.dataId),[f,x]=(0,Yn.UC)(h,p,r,i,a,s,u,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",x)]}},nt={kernelName:o.iW0,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{skipEmpty:r}=o,{input:i,delimiter:a}=n;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const s=t.readSync(i.dataId),u=t.readSync(a.dataId)[0],[c,l,d]=(0,Yn.S6)(s,u,r),h=l.length;return[t.makeTensorInfo([h,2],"int32",c),t.makeTensorInfo([h],"string",l),t.makeTensorInfo([2],"int32",new Int32Array(d))]}},tt={kernelName:o.$jE,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{numBuckets:r}=o,{input:i}=n;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(i.dataId),s=(0,Yn.fW)(a,r);return t.makeTensorInfo(i.shape,"int32",s)}};var ot=t(38483),rt=t(22853),it=t(15411);const at=(0,it.vi)({opSnippet:"return tan(x);"}),st={kernelName:o.oFs,backendName:"webgl",kernelFunc:at},ut=(0,it.vi)({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),ct={kernelName:o.iuW,backendName:"webgl",kernelFunc:ut};class lt{constructor(e,n){this.variableNames=["A"];const t=new Array(e.length);for(let o=0;o<t.length;o++)t[o]=e[o]*n[o];this.outputShape=t,this.rank=t.length;const o=(0,qn.bf)(this.rank),r=function(e){const n=e.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${e[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],o=[];for(let n=0;n<e.length;n++)o.push(`imod(${t[n]}, ${e[n]})`);return o.join()}(e);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function dt(e){const{inputs:n,backend:t,attrs:r}=e,{x:i}=n,{reps:a}=r;if("string"===i.dtype||i.shape.length>5){const e=t.readSync(i.dataId),n="string"===i.dtype?e.map((e=>o.ZSL.decodeString(e))):e,r=(0,o.ra8)(i.shape,i.dtype,n),s=(0,Yn.$O)(r,a);return t.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new lt(i.shape,a);return t.runWebGLProgram(s,[i],i.dtype)}const ht={kernelName:o.FAs,backendName:"webgl",kernelFunc:dt};class pt{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class ft{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function xt(e,n){null!==n&&e.disposeIntermediateTensorInfo(n)}function $t(e){let n=1;for(;n<e;)n*=2;return n}const vt={kernelName:o.TBb,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:i}=n,{k:a,sorted:s}=r,u=(0,o._K2)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=(0,o._K2)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=i.shape,d=l[l.length-1];if(t.shouldExecuteOnCPU([i])||d<u||a>c){const e=t.readSync(i.dataId),[n,o]=(0,Yn.xt)(e,l,i.dtype,a,s);return[t.makeTensorInfo(n.shape,n.dtype,n.values),t.makeTensorInfo(o.shape,o.dtype,o.values)]}if(0===a)return l[l.length-1]=0,[t.makeTensorInfo(l,i.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(1===d)return[i,(0,ue.G)({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const h=t.texData.get(i.dataId),p=null!==h&&h.isPacked,f=p?t.unpackTensor(i):i,x=o.ZSL.sizeFromShape(l)/d,$=(0,gn.t)({inputs:{x:f},attrs:{shape:[x,d]},backend:t});p&&xt(t,f);const v=$t(a),g=$t(d);let C=null;const m=()=>null===C?[$,$]:[$,C],R=(e,n,o)=>{const r=m(),i=new pt(o),a=[[d],[null===C?1:0],[Number.NEGATIVE_INFINITY],[e],[n]],s=C;C=t.runWebGLProgram(i,r,"int32",a),xt(t,s)};for(let e=1;e<v;e*=2){const n=2*e;for(let t=e;t>=1;t/=2)R(n,t,[x,g])}for(let e=g;e>v;e/=2){const n=m(),o=new ft([x,e/2]),r=[[d],[null===C?1:0],[v]],i=C;C=t.runWebGLProgram(o,n,"int32",r),xt(t,i);const a=v/2,s=2*a;for(let e=a;e>=1;e/=2)R(s,e,C.shape)}let b=C;C=(0,_n.d)({inputs:{x:C},backend:t,attrs:{begin:0,size:[x,a]}}),xt(t,b);let S=(0,$e.C)({inputs:{x:$,indices:C},backend:t,attrs:{axis:1,batchDims:1}});xt(t,$);const T=l.slice(0,-1);T.push(a),b=C,C=(0,gn.t)({inputs:{x:C},attrs:{shape:T},backend:t}),xt(t,b);const y=S;return S=(0,gn.t)({inputs:{x:S},attrs:{shape:T},backend:t}),xt(t,y),[S,C]}};class gt{constructor(e,n,t,o,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===t?1:2;let s;switch(o){case"constant":default:s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${s} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${n}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Ct={kernelName:o.dLy,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{image:r,transforms:i}=n,{interpolation:a,fillMode:s,fillValue:u,outputShape:c}=o,[l,d,h,p]=r.shape,[f,x]=null!=c?c:[d,h],$=new gt(d,h,a,s,u,[l,f,x,p]);return t.runWebGLProgram($,[r,i],"float32")}};var mt=t(58246),Rt=t(88380);const bt={kernelName:o.EwU,backendName:"webgl",kernelFunc:function(e){const{inputs:n,attrs:t,backend:o}=e,{axis:r}=t,{x:i}=n;(0,Rt.CE)(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=o.readSync(i.dataId),{outputValues:s,outputShape:u,indices:c}=(0,Yn.M_)(a,r,i.shape,i.dtype);return[o.makeTensorInfo(u,i.dtype,s),o.makeTensorInfo([c.length],"int32",c)]}},St={kernelName:o.dXR,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{value:r}=n;let{axis:i}=o;i<0&&(i+=r.shape.length);const a=r,s=a.shape.length,u=r.shape[i],c=new Array(s-1);let l=0;for(let e=0;e<s;e++)e!==i&&(c[l++]=a.shape[e]);const d=[],h=new Array(s).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(u);for(let e=0;e<f.length;e++){h[i]=e;const n=(0,_n.d)({inputs:{x:a},backend:t,attrs:{begin:h,size:p}}),o=(0,gn.t)({inputs:{x:n},backend:t,attrs:{shape:c}});f[e]=o,d.push(n)}return d.forEach((e=>t.disposeIntermediateTensorInfo(e))),f}};class Tt{constructor(e,n){this.variableNames=["x","segmentIds"];const t=e.windowSize,o=e.batchSize,r=e.inSize,i=e.numSegments,a=i*Math.ceil(r/t);this.outputShape=[o,a];const s=4*Math.floor(t/4),u=t%4,c="\n        sumValue += dot(values, segFilter);\n    ";let l="";r%t>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let d="";r%t>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${t}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}const yt={kernelName:o.pPe,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:i,segmentIds:a}=n,{numSegments:s}=r,u=i.shape.length,c=[];let l=0;const d=o.backend_util.getAxesPermutation([l],u);let h=i;null!=d&&(h=(0,mt.m)({inputs:{x:i},backend:t,attrs:{perm:d}}),c.push(h),l=o.backend_util.getInnerMostAxes(1,u)[0]);const p=o.backend_util.segment_util.computeOutShape(h.shape,l,s),f=o.ZSL.sizeFromShape([h.shape[l]]),x=(0,gn.t)({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}});c.push(x);const $=(0,o.chL)(i.dtype),v=(e,n,r,i,a)=>{const s=e.shape[0],u=e.shape[1],l=o.backend_util.segment_util.segOpComputeOptimalWindowSize(u,a),d=new Tt({windowSize:l,inSize:u,batchSize:s,numSegments:a},n),h=t.compileAndRun(d,[e,r],i);if(c.push(h),h.shape[1]===a)return h;const p=(0,hn.y)({backend:t,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),f=dt({inputs:{x:p},backend:t,attrs:{reps:[u/l]}});return c.push(p),c.push(f),v(h,n,f,i,a)},g=v(x,"unsortedSegmentSum",a,$,s),C=(0,gn.t)({inputs:{x:g},backend:t,attrs:{shape:p}});let m=C;if(null!=d){c.push(C);const e=o.backend_util.getUndoAxesPermutation(d);m=(0,mt.m)({inputs:{x:m},backend:t,attrs:{perm:e}})}return c.forEach((e=>t.disposeIntermediateTensorInfo(e))),m}};var wt=t(30097);const It=[i,a.l,s.t,u.D,c.U,l.y,d.k,h.l,p.n,f.l,x.S,$.M,v.L,g.r,C.l,m.R,R.O,b.m,S.$,T.X,y.V,w.e,I.l,k.N,E.M,F.u,O.F,A.v,N.t,V.V,_.x,D.r,U.f,L.i,M.i,z.Y,P.o,B.k,X.O,W.T,j.$,G.Y,H.R,K.v,Z.n,Y.V,q.O,J.F,Q._,ee.J,ne.x,te.R,oe._,re.AC,ie.a,ae.Y,se.N,ue.u,ce.D,le.H,de.U,he.y,pe.q,fe.l,xe.K,$e.a,ve.x,ge.V,Ce.F,me.c,Re.l,be.K,Se.I,Te.I,ye.zp,we.Y,Ie.Q,ke.o,Ee.F,Fe.W,Oe.V,Ae.f,Ne.r,Ve.x,_e.j,De.l,Ue.l,Le.$,Me.A,ze.S,Pe.P,Be.l,Xe.M,We.j,je.N,Ge.V,He.X,Ke.a,Ze.t,Ye.h,qe.m,Je.F,Qe.u,en.A,nn._,tn.h,on.q,rn.e,an.j,sn.HK,un.S,cn.i,ln.Y,dn.g,hn.i,pn.r,fn.G,xn.l,$n.z,vn.X,gn.V,Cn.T,mn.j,Rn.j,bn.n,Sn.r,Tn.f,yn.$,wn.L,In.H,kn.M,En.z,Fn.k,On.X,An.C,Nn.b,Vn.$,_n.l,Dn.$,Un.Z,Ln.W,Mn.K,zn.F,Pn.v,Bn.j,Xn.x,Wn.t,jn.F,Gn.e,Hn.b,Zn,Qn,et,nt,tt,ot.Z,rt.q,st,ct,ht,vt,Ct,mt.W,bt,St,yt,wt.Z];for(const e of It)(0,o.tAK)(e)},1404:(e,n,t)=>{t.d(n,{R:()=>i});var o=t(22792),r=t(92394);class i{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=(0,o.ik)(this.outputShape.length);let t="";for(let e=0;e<4;e++){let n="thisRC = rc;";e%2==1&&(n+="thisRC.z += 1;"),e>1&&(n+="thisRC.y += 1;"),t+=`\n        ${n}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var i,a;this.userCode=`\n      ${i=n,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?r.TN(["r","c","d"],"inputShape"):r.UG(["r","c","d"],i)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?r.Od():r.fM(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${t}\n\n        setOutput(result);\n      }\n    `}}},47791:(e,n,t)=>{t.d(n,{h:()=>o});class o{constructor(e,n,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,o,r]=n,[,i,a]=e,s=[t&&i>1?o-1:o,t&&a>1?r-1:r],u=[t&&i>1?i-1:i,t&&a>1?a-1:a],c=s[0]/u[0],l=s[1]/u[1],d=1/c,h=1/l,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}},26180:(e,n,t)=>{t.d(n,{z:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["A"],this.outputShape=[];const[i,a,s,u]=e;this.outputShape=[i,n,t,u];const c=[o&&n>1?a-1:a,o&&t>1?s-1:s],l=[o&&n>1?n-1:n,o&&t>1?t-1:t];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}},16853:(e,n,t)=>{t.d(n,{x:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,s,u]=e;this.outputShape=[i,n,t,u];const c=[o&&n>1?a-1:a,o&&t>1?s-1:s],l=[o&&n>1?n-1:n,o&&t>1?t-1:t];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]},\n          ${c[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${t-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}},27436:(e,n,t)=>{t.d(n,{x:()=>o});class o{constructor(e,n,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,o,r]=n,[,i,a]=e,s=[t&&i>1?o-1:o,t&&a>1?r-1:r],u=[t&&i>1?i-1:i,t&&a>1?a-1:a],c=s[0]/u[0],l=s[1]/u[1],d=1/c,h=1/l,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${o}) - 1),\n                ${t} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${t} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}},6917:(e,n,t)=>{t.d(n,{$:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["A"],this.outputShape=[];const[i,a,s,u]=e;this.outputShape=[i,n,t,u];const c=[o&&n>1?a-1:a,o&&t>1?s-1:s],l=[o&&n>1?n-1:n,o&&t>1?t-1:t],d=o?"0.5":"0.0";let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}},59250:(e,n,t)=>{t.d(n,{z:()=>o});class o{constructor(e,n,t,o,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,s,u]=e;this.outputShape=[i,n,t,u];const c=[o&&n>1?a-1:a,o&&t>1?s-1:s],l=[o&&n>1?n-1:n,o&&t>1?t-1:t],d=o?"0.5":"0.0";let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/l[0]},\n          ${c[1]/l[1]},\n          ${c[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${t-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}},71967:(e,n,t)=>{t.d(n,{N:()=>r});var o=t(27575);class r{constructor(e,n){this.variableNames=["x"];const t=e.length;if(t>4)throw new Error(`WebGL backend: Reverse of rank-${t} tensor is not yet supported`);if(this.outputShape=e,1===t)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((t,o)=>(t=>-1!==n.indexOf(t)&&1!==e[t]?`${e[t]} - coords[${t}] - 1`:`coords[${t}]`)(o))).join(","),i=(0,o.bf)(t);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}},68636:(e,n,t)=>{t.d(n,{X:()=>i});var o=t(75694),r=t(27575);class i{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const t=e.length;if(t>4)throw new Error(`WebGL backend: Reverse of rank-${t} tensor is not yet supported`);this.outputShape=e;const i=(0,o.Jp)("rc",t),a=`${i[t-1]} + 1 < ${this.outputShape[t-1]}`,s=`${i[t-2]} + 1 < ${this.outputShape[t-2]}`,u=(0,r.bf)(t);function c(t){const o=e.map(((o,r)=>function(t,o){return-1!==n.indexOf(t)&&1!==e[t]?`${e[t]} - ${o[t]} - 1`:`${o[t]}`}(r,t)));return`getChannel(getX(${o.join(",")}), vec2(${o.slice(-2).join(",")}))`}this.userCode=1===t?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${u} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return c(e)}(i.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[t-1]="("+e[t-1]+" + 1)",c(e)}(i.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[t-2]="("+e[t-2]+" + 1)",c(e)}(i.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[t-1]="("+e[t-1]+" + 1)",e[t-2]="("+e[t-2]+" + 1)",c(e)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}},40784:(e,n,t)=>{t.d(n,{e:()=>o});class o{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const t=e[1],o=e[2];this.outputShape=e;let r="";r="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${t}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}},8939:(e,n,t)=>{t.d(n,{$:()=>r});var o=t(27575);class r{constructor(e,n,t,r,i,a,s=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=(0,o.bf)(i.length),c=(0,o.bf)(a.length);let l="";1===t?l="i":2===t&&(l="i, j");const d=`getIndices(${l})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`,f=n>1?"strides[j]":"strides";this.userCode=`\n        ${u} strides = ${u}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${f};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}},473:(e,n,t)=>{t.d(n,{i:()=>r});var o=t(36115);class r{constructor(e,n,t,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,t];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=2===(0,o._K2)().getNumber("WEBGL_VERSION")?"while (left < right) {":i,s="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${s} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}},81847:(e,n,t)=>{t.d(n,{T:()=>r});var o=t(27575);class r{constructor(e,n,t){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error(`Where for rank ${t} is not yet supported`);if(1===t)i="resRC",r="resRC";else{const t=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=[];for(let r=0;r<n.length;r++)a.push(`${t[r]}`),r<e&&o.push(`${t[r]}`);r=o.join(),i=a.join()}const a=(0,o.bf)(t);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}},27575:(e,n,t)=>{t.d(n,{YE:()=>v,bf:()=>$,yr:()=>s});var o=t(36115),r=t(18765),i=t(92394);const{getBroadcastDims:a}=o.backend_util;function s(e,n,t){const s=[];if(e.forEach((e=>{const n=o.ZSL.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`)),t.enableShapeUniforms){const{uniformShape:n}=v(t.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(n.length){case 1:s.push(`uniform int ${e.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${e.name}Shape;`)}s.push(`uniform ivec2 ${e.name}TexShape;`)}})),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;")}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach((e=>{s.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const f=s.join("\n"),x=e.map((e=>function(e,n,t=!1,r){let i="";i+=t?c(e,r):u(e,r);const s=e.shapeInfo.logicalShape,l=n.logicalShape;return s.length<=l.length&&(i+=t?function(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),i="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,u=n.logicalShape.length,c=a(e.shapeInfo.logicalShape,n.logicalShape),l=$(u),d=u-s;let h;const p=["x","y","z","w","u","v"];h=0===s?"":u<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=u<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${p[n+d]}`)).join(", ");let x="return outputValue;";const v=1===o.ZSL.sizeFromShape(e.shapeInfo.logicalShape),g=1===o.ZSL.sizeFromShape(n.logicalShape);if(1!==s||v||g){if(v&&!g)x=1===u?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(c.length){const e=s-2,n=s-1;c.indexOf(e)>-1&&c.indexOf(n)>-1?x="return vec4(outputValue.x);":c.indexOf(e)>-1?x="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":c.indexOf(n)>-1&&(x="return vec4(outputValue.xx, outputValue.zz);")}}else x="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${r}(${f});\n      ${x}\n    }\n  `}(e,n):function(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),i="get"+r+"AtOutCoords",s=n.texShape,u=e.shapeInfo.texShape,c=e.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!e.shapeInfo.isUniform&&c===l&&null==e.shapeInfo.flatOffset&&o.ZSL.arraysEqual(u,s))return`\n      float ${i}() {\n        return sampleTexture(${t}, resultUV);\n      }\n    `;const d=$(l),h=a(e.shapeInfo.logicalShape,n.logicalShape),p=l-c;let f;const x=["x","y","z","w","u","v"];f=0===c?"":l<2&&h.length>=1?"coords = 0;":h.map((e=>`coords.${x[e+p]} = 0;`)).join("\n");let v="";return v=l<2&&c>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${x[n+p]}`)).join(", "),`\n    float ${i}() {\n      ${d} coords = getOutputCoords();\n      ${f}\n      return get${r}(${v});\n    }\n  `}(e,n)),i}(e,n,t.packedInputs,t.enableShapeUniforms))).join("\n"),g=n.texShape,C=(0,r.B)(),m=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(C);let R,b,S=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${l}\n    ${d}\n    ${h}\n  `}(C);return n.isPacked?(R=function(e,n,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,n,t){const o=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===o[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${o[1]}.0);\n      }\n    `:1===o[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${o[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      return 2 * (resTexRC.x * ${o[1]} + resTexRC.y);\n    }\n  `}(0,n,t);case 2:return function(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(o.ZSL.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(e[1]/2);return t?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const o=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n,t);default:return function(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const o=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2);let a=i,s="",u="b, r, c";for(let n=2;n<e.length-1;n++)a*=e[e.length-n-1],s=`\n      int b${n} = index / ${a};\n      index -= b${n} * ${a};\n    `+s,u=`b${n}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${o[0]}, ${o[1]}));\n      int index = resTexRC.x * ${o[1]} + resTexRC.y;\n\n      ${s}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,n,t)}}(n.logicalShape,g,t.enableShapeUniforms),b=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(C)):(R=function(e,n,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,n,t){return 1===n[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,t);case 2:return function(e,n,t){return o.ZSL.arraysEqual(e,n)?t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===e[1]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:t?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${i.WA(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const o=i.UG(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${o}\n      return ivec3(r, c, d);\n    }\n  `}(e,n,t);case 4:return function(e,n,t){if(t)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${i.WA(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const o=i.UG(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${o}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n,t);case 5:return function(e,n){const t=i.UG(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function(e,n){const t=i.UG(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(n.logicalShape,g,t.enableShapeUniforms),b=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(C)),t.packedInputs&&(S+=p),[S,m,b,f,R,x,t.userCode].join("\n")}function u(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e,n){const t=e.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${o}() {return ${t};}`;const[r,i]=e.shapeInfo.texShape;if(1===r&&1===i)return`\n      float ${o}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=f(t);if(n)return`\n    float ${o}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[s,u]=e.shapeInfo.texShape;return`\n    float ${o}() {\n      vec2 uv = uvFromFlat(${s}, ${u}, ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 1:return function(e,n){const t=e.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${o}(int index) {\n        ${x(e)}\n      }\n    `;const r=e.shapeInfo.texShape,i=r[0],a=r[1];if(1===a&&1===i)return`\n      float ${o}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const s=f(t);return 1===a?n?`\n      float ${o}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${o}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${i}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===i?n?`\n      float ${o}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${o}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:n?`\n    float ${o}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `:`\n    float ${o}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${a}, index + ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&o.ZSL.arraysEqual(t,a)){if(n)return`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:s,keptDims:c}=o.ZSL.squeezeShape(t),l=s;if(l.length<t.length){const t=["row","col"];return`\n      ${u(g(e,l),n)}\n      float ${i}(int row, int col) {\n        return ${i}(${C(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${x(e)}\n      }\n    `;const d=a[0],h=a[1],p=f(r);return 1===h?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===d?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${d}, ${h}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t[1]*t[2],s=t[2],{newShape:c,keptDims:l}=o.ZSL.squeezeShape(t),d=c;if(d.length<t.length){const t=["row","col","depth"];return`\n        ${u(g(e,d),n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${C(t,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${s}, 1)));\n        ${x(e)}\n      }\n    `;const h=e.shapeInfo.texShape,p=h[0],$=h[1],v=e.shapeInfo.flatOffset;if($===a&&null==v)return n?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${$}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if($===s&&null==v)return n?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${$}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const m=f(r);return n?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${m};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${s} + depth + ${m};\n        vec2 uv = uvFromFlat(${p}, ${$}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,n);case 4:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t[3],s=t[2]*a,c=t[1]*s,{newShape:l,keptDims:d}=o.ZSL.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${u(g(e,l),n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${C(t,d)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${c}, ${s}, ${a}, 1)));\n        ${x(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,$=p[0],v=p[1],m=`int stride2 = ${r}Shape[3];`,R=`int stride1 = ${r}Shape[2] * stride2;`,b=`int stride0 = ${r}Shape[1] * stride1;`;if(v===c&&null==h)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${R}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${$}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(v===a&&null==h)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${$}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const S=f(r);return n?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${R}\n      ${b}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${S});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${s} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${$}, ${v}, index + ${S});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,n);case 5:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n[4],a=n[3]*i,s=n[2]*a,c=n[1]*s,{newShape:l,keptDims:d}=o.ZSL.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2","depth3"];return`\n      ${u(g(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${C(n,d)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${s}, ${a}, ${i})) +\n          depth3;\n        ${x(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,$=p[0],v=p[1];if(v===c&&null==h)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${$}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(v===i&&null==h)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${$}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${s} + depth * ${a} +\n          depth2 * ${i} + depth3 + ${f(t)};\n      vec2 uv = uvFromFlat(${$}, ${v}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:a}=o.ZSL.squeezeShape(n);if(i.length<n.length){const n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${u(g(e,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${C(n,a)});\n      }\n    `}const s=n[5],c=n[4]*s,l=n[3]*c,d=n[2]*l,h=n[1]*d;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${d}, ${l}, ${c})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${x(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,$=e.shapeInfo.texShape,v=$[0],m=$[1];if(m===h&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${d}, ${l}, ${c}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${v}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(m===s&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${v}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${d} + depth * ${l} +\n          depth2 * ${c} + depth3 * ${s} + depth4 + ${f(t)};\n      vec2 uv = uvFromFlat(${v}, ${m}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function c(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const n=e.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${(0,r.B)().texture2D}(${n}, halfCR);\n    }\n  `}(e);case 1:return function(e,n){const t=e.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e.shapeInfo.texShape,a=(0,r.B)();if(n)return`\n    vec4 ${o}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `;const s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${o}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,i=e.name,a="get"+i.charAt(0).toUpperCase()+i.slice(1),s=e.shapeInfo.texShape,u=s[0],c=s[1],l=(0,r.B)();if(null!=s&&o.ZSL.arraysEqual(t,s))return n?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${u}.0);\n\n        return ${l.texture2D}(${i}, uv);\n      }\n    `;if(n)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `;const d=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${d[0]}, ${d[1]}, row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,o=e.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),a=e.shapeInfo.texShape,s=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===t[0]){const o=[1,2],r=["b","row","col"];return`\n        ${c(g(e,t.slice(1)),n)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${C(r,o)});\n        }\n      `}const u=(0,r.B)();if(n)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${u.texture2D}(${o}, uv);\n    }\n  `;const l=s[0],d=s[1],h=Math.ceil(t[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${d}, ${h*Math.ceil(t[1]/2)}, ${h}, b, row, col);\n      return ${u.texture2D}(${o}, uv);\n    }\n  `}(e,n);default:return function(e,n){const t=e.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),i=(0,r.B)();if(n)return`\n    vec4 ${o}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,s=a.length,u=e.shapeInfo.texShape,c=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],l=c[0],d=c[1],h=Math.ceil(a[s-1]/2);let p=h*Math.ceil(a[s-2]/2),f="int b, int row, int col",x=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let e=2;e<s-1;e++)f=`int b${e}, `+f,p*=a[s-e-1],x=`b${e} * ${p} + `+x;return`\n    vec4 ${o}(${f}) {\n      int index = ${x};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${l});\n      return ${i.texture2D}(${t}, uv);\n    }\n  `}(e,n)}}const l="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",d="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",h="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",p="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function f(e){return`offset${e}`}function x(e){const n=e.name,t=o.ZSL.sizeFromShape(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`\n    for (int i = 0; i < ${t}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function $(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function v(e,n,t){const{newShape:r,keptDims:i}=o.ZSL.squeezeShape(n),a=n.length,s=e&&3===a&&1===n[0],u=s?n.slice(1):r,c=!e&&a>1&&!o.ZSL.arraysEqual(n,t)&&r.length<a||s;return{useSqueezeShape:c,uniformShape:c?u:n,keptDims:i}}function g(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function C(e,n){return n.map((n=>e[n])).join(", ")}},92394:(e,n,t)=>{t.d(n,{G2:()=>c,Od:()=>u,TN:()=>a,UG:()=>r,WA:()=>i,fM:()=>s});var o=t(36115);function r(e,n,t="index"){const r=o.ZSL.computeStrides(n);return r.map(((n,o)=>`int ${e[o]} = ${t} / ${n}; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * ${n}`:`index -= ${e[o]} * ${n}`};`)).join("")}function i(e,n,t="index"){const r=o.ZSL.computeStrides(n);return r.map(((n,o)=>`int ${e[o]} = ${t} / outShapeStrides[${o}]; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * outShapeStrides[${o}]`:`index -= ${e[o]} * outShapeStrides[${o}]`};`)).join("")}function a(e,n,t="index"){const o=function(e,n){const t=e.length,o=e.map((e=>`${n}[${e}]`)),r=new Array(t-1);r[t-2]=o[t-1];for(let e=t-3;e>=0;--e)r[e]=`(${r[e+1]} * ${o[e+1]})`;return r}(e.map(((e,n)=>n)),n);return o.map(((n,r)=>`int ${e[r]} = ${t} / ${o[r]}; ${r===o.length-1?`int ${e[r+1]} = ${t} - ${e[r]} * ${o[r]}`:`index -= ${e[r]} * ${o[r]}`};`)).join("")}function s(e){const n=o.ZSL.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function u(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}const c="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"},10043:(e,n,t)=>{t.d(n,{J:()=>r});var o=t(27575);class r{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=(0,o.bf)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=function(e){if(1===e)return"sourceLoc";if(e<=6)return i.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${e.map(((e,n)=>`sourceLoc.${i[n]} = start[${n}] + coords.${i[n]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${t}));\n      }\n    `}}const i=["x","y","z","w","u","v"]},5144:(e,n,t)=>{t.d(n,{V:()=>i});var o=t(75694),r=t(27575);class i{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=(0,r.bf)(this.rank),t=(0,o.Jp)("coords",this.rank),i=(0,o.Jp)("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,s=`getChannel(getSource(${i.join()}), ${a})`,u=`\n      result.x = ${s};\n      if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${s};\n        --${i[this.rank-1]};\n      }\n    `,c=1===this.rank?"":`\n      --${t[this.rank-1]};\n      if (++${t[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${s};\n        if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${n}(${e.map(((e,n)=>`start[${n}]`)).join()});`:e.map(((e,n)=>`${i[n]} = ${t[n]} + start[${n}];`)).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${u}\n        ${c}\n        setOutput(result);\n      }\n    `}}},28560:(e,n,t)=>{t.d(n,{BB:()=>o,EX:()=>u,EZ:()=>h,GM:()=>c,NO:()=>l,PM:()=>d,Qn:()=>s,j:()=>i,tT:()=>r});var o,r,i,a=t(36115);function s(e,n){return[n,e]}function u(e,n){return e*n}function c(e){const n=a.ZSL.sizeFromShape(e),t=Math.ceil(n/4);return a.ZSL.sizeToSquarishShape(t)}function l(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function d(e,n){const[t,o]=l(e,n);return t*o*4}function h(e,n){const t=e;let o,r,i,s,u,c,l,d,h,p;return 2===(0,a._K2)().getNumber("WEBGL_VERSION")?(o=t.R32F,r=t.R16F,i=t.RGBA16F,s=t.RGBA32F,u=t.RED,l=4,d=1,h=t.HALF_FLOAT,p=t.FLOAT,c=t.RGBA8):(o=e.RGBA,r=e.RGBA,i=e.RGBA,s=t.RGBA,u=e.RGBA,l=4,d=4,h=null!=n?n.HALF_FLOAT_OES:null,p=e.FLOAT,c=e.RGBA),{internalFormatFloat:o,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:s,textureFormatFloat:u,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(o||(o={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(r||(r={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(i||(i={}))},47403:(e,n,t)=>{t.d(n,{p:()=>a});var o=t(36115),r=t(47646),i=t(28560);class a{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,n,t){const o=u(n,t),r=c(e,o,t);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=s(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,t);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let l;return o===i.j.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===i.j.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===i.j.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===i.j.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===i.j.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(l),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),l}releaseTexture(e,n,t,r){if(null==this.freeTextures)return;const i=u(t,r),a=c(n,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const l=s(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),d=(0,o._K2)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==d&&this._numBytesAllocated>d?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const h=this.usedTextures[a],p=h.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h.splice(p,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function s(e,n,t,o,a){const s=function(e,n){switch(e){case i.j.PACKED_2X2_FLOAT32:return(0,r.Ij)(n);case i.j.PACKED_2X2_FLOAT16:return(0,r.z8)(n);case i.j.UNPACKED_FLOAT32:return(0,r.fj)(n);case i.j.UNPACKED_FLOAT16:return(0,r.J$)(n);case i.j.PACKED_4X1_UNSIGNED_BYTE:return(0,r.wM)(n);default:throw new Error(`Unknown physical texture type ${e}`)}}(n,o);let u;if(a){const[n,t]=(0,i.NO)(e[0],e[1]);u=n*t}else{const[n,t]=(0,i.Qn)(e[0],e[1]);u=n*t}const c=function(e,n){const t=e;if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===e.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(t,s);return u*c}function u(e,n){if(e===i.tT.UPLOAD)return i.j.PACKED_2X2_FLOAT32;if(e===i.tT.RENDER||null==e)return function(e){return(0,o._K2)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?i.j.PACKED_2X2_FLOAT32:i.j.UNPACKED_FLOAT32:e?i.j.PACKED_2X2_FLOAT16:i.j.UNPACKED_FLOAT16}(n);if(e===i.tT.DOWNLOAD||e===i.tT.PIXELS)return i.j.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function c(e,n,t){return`${e[0]}_${e[1]}_${n}_${t}`}},68173:(e,n,t)=>{t.d(n,{Hq:()=>h,Nb:()=>l,UC:()=>d,X0:()=>u,X8:()=>c,_Q:()=>a,dR:()=>i,hE:()=>r,pd:()=>s});var o=t(22792);class r{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=(0,o.ik)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${n}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const i="if (isnan(x)) return x;",a="return x;",s="return abs(x);",u="return (x >= 0.0) ? x : (exp(x) - 1.0);",c=i+"\n  return (x < 0.0) ? 0.0 : x;\n",l=i+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",d="return x;",h="return 1.0 / (1.0 + exp(-1.0 * x));"},74890:(e,n,t)=>{t.d(n,{Hq:()=>u,Nb:()=>s,X0:()=>i,X8:()=>a,_Q:()=>r,rf:()=>c});var o=t(22792);const r="return x;",i="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",a="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",s="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",u="return 1.0 / (1.0 + exp(-1.0 * x));";class c{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=(0,o.ik)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${n}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}},46969:(e,n,t)=>{t.d(n,{z:()=>a});var o=t(22792),r=t(75694),i=t(27575);class a{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=(0,o.ik)(this.outputShape.length);const n=e.length,t=(0,r.Jp)("rc",n),a=(0,i.bf)(n),s=(0,r.kp)(n,t),u=t.slice(-2),c=n<=1?"rc":`vec2(${u.join(",")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${c}));\n      }\n    `}}},80393:(e,n,t)=>{t.d(n,{bP:()=>r});var o=t(36115);function r(){(0,o._K2)().set("WEBGL_FORCE_F16_TEXTURES",!0)}},88380:(e,n,t)=>{t.d(n,{$e:()=>C,CE:()=>K,FP:()=>N,HM:()=>l,HW:()=>g,I2:()=>W,N0:()=>O,N6:()=>j,P0:()=>D,Ph:()=>A,Ql:()=>B,R7:()=>$,Rh:()=>T,SO:()=>I,Se:()=>M,Ut:()=>H,VJ:()=>P,Yn:()=>y,Zj:()=>X,bz:()=>v,cr:()=>f,dm:()=>c,fA:()=>V,jL:()=>z,oN:()=>b,ph:()=>R,rC:()=>x,rw:()=>S,s6:()=>E,sA:()=>k,sZ:()=>m,ul:()=>a,yG:()=>h,y_:()=>w,yr:()=>d});var o=t(36115),r=t(597),i=t(28560);function a(e,n){const t=n();return(0,o._K2)().getBool("DEBUG")&&function(e){const n=e.getError();if(n!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(e,n))}(e),t}const s=5.96e-8,u=65504;function c(e){return!!((0,o._K2)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||s<Math.abs(e)&&Math.abs(e)<u)}function l(e,n){return F(e,(()=>e.getExtension(n)),'Extension "'+n+'" not supported on this browser.')}function d(e,n){const t=F(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(a(e,(()=>e.shaderSource(t,n))),a(e,(()=>e.compileShader(t))),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function h(e,n){const t=F(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(a(e,(()=>e.shaderSource(t,n))),a(e,(()=>e.compileShader(t))),(0,o._K2)().get("ENGINE_COMPILE_ONLY"))return t;if(!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw f(n,e.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const p=/ERROR: [0-9]+:([0-9]+):/g;function f(e,n){const t=p.exec(n);if(null==t)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(e);const r=+t[1],i=e.split("\n"),a=i.length.toString().length+2,s=i.map(((e,n)=>o.ZSL.rightPad((n+1).toString(),a)+e));let u=0;for(let e=0;e<s.length;e++)u=Math.max(s[e].length,u);const c=s.slice(0,r-1),l=s.slice(r-1,r),d=s.slice(r);console.log(c.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${o.ZSL.rightPad(l[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function x(e){return F(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function $(e,n){if(a(e,(()=>e.linkProgram(n))),!(0,o._K2)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function v(e,n){if(a(e,(()=>e.validateProgram(n))),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function g(e,n){const t=F(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return a(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,t))),a(e,(()=>e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW))),t}function C(e,n){const t=F(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return a(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t))),a(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW))),t}function m(e){return F(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function R(e,n){const t=(0,o._K2)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0)throw new Error(`Requested texture size [${e}x${n}] is invalid.`);if(e>t||n>t)throw new Error(`Requested texture size [${e}x${n}] greater than WebGL maximum on this browser / GPU [${t}x${t}].`)}function b(e){return F(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function S(e,n,t,o,r,i,s){const u=e.getAttribLocation(n,t);return-1!==u&&(a(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,o))),a(e,(()=>e.vertexAttribPointer(u,r,e.FLOAT,!1,i,s))),a(e,(()=>e.enableVertexAttribArray(u))),!0)}function T(e,n,t){return F(e,(()=>e.getUniformLocation(n,t)),'uniform "'+t+'" not present in program.')}function y(e,n,t){return e.getUniformLocation(n,t)}function w(e,n,t,o){a(e,(()=>function(e,n,t){(function(e,n){const t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,o=n+e.TEXTURE0;if(o<e.TEXTURE0||o>t)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${t}].`)})(e,t),a(e,(()=>e.activeTexture(e.TEXTURE0+t))),a(e,(()=>e.bindTexture(e.TEXTURE_2D,n)))}(e,n,o))),a(e,(()=>e.uniform1i(t,o)))}function I(e,n,t){a(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),a(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)))}function k(e,n){a(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),a(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function E(e){const n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(e,n))}function F(e,n,t){const o=a(e,(()=>n()));if(null==o)throw new Error(t);return o}function O(e,n=2){return o.ZSL.sizeFromShape(e.slice(0,e.length-n))}function A(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function N(e){let n=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(n=[O(e),...A(e)]),n}function V(e,n=!1){let t=(0,o._K2)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,o._K2)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&(0,o._K2)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),n&&(t*=2,r*=2,1===(e=e.map(((n,t)=>t>=e.length-2?o.ZSL.nearestLargerEven(e[t]):e[t]))).length&&(e=[2,e[0]])),2!==e.length){const n=o.ZSL.squeezeShape(e);e=n.newShape}let i=o.ZSL.sizeFromShape(e),a=null;e.length<=1&&i<=t?a=[1,i]:2===e.length&&e[0]<=t&&e[1]<=t?a=e:3===e.length&&e[0]*e[1]<=t&&e[2]<=t?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=t&&e[1]*e[2]<=t?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=t&&e[3]<=t?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=t&&e[1]*e[2]*e[3]<=t&&(a=[e[0],e[1]*e[2]*e[3]]);const s=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(n?2:1)&&Math.min(...a)>0;if(null==a||s)if(n){const n=O(e);let t=2,r=2;e.length&&([t,r]=A(e)),i=n*(t/2)*(r/2),a=o.ZSL.sizeToSquarishShape(i).map((e=>2*e))}else a=o.ZSL.sizeToSquarishShape(i);return a}function _(e){return e%2==0}function D(e,n){if(e=e.slice(-2),n=n.slice(-2),o.ZSL.arraysEqual(e,n))return!0;if(!e.length||!n.length)return!0;if(0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){const t=e.slice(-1)[0],o=n.slice(-1)[0];if(t===o)return!0;if(_(t)&&_(o)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&_(e[0])&&_(n[0])}let U,L;function M(e){if(null==U){const n=(0,r.bU)(e);U=n.getParameter(n.MAX_TEXTURE_SIZE)}return U}function z(e){if(null==L){const n=(0,r.bU)(e);L=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,L)}function P(e){if(0===e)return 0;let n;const t=(0,r.bU)(e);return n=B(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:B(t,"EXT_disjoint_timer_query")?1:0,n}function B(e,n){return null!=e.getExtension(n)}function X(e){try{if(null!=(0,r.bU)(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function W(e){if(0===e)return!1;const n=(0,r.bU)(e);if(1===e){if(!B(n,"OES_texture_float"))return!1}else if(!B(n,"EXT_color_buffer_float"))return!1;return G(n)}function j(e){if(0===e)return!1;const n=(0,r.bU)(e);if(1!==e){if(B(n,"EXT_color_buffer_float"))return G(n);const e="EXT_color_buffer_half_float";if(B(n,e)){const t=n.getExtension(e);return function(e,n){const t=(0,i.EZ)(e,n),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(o),e.deleteFramebuffer(r),a}(n,t)}return!1}return!!B(n,"OES_texture_float")&&(!!B(n,"WEBGL_color_buffer_float")&&G(n))}function G(e){const n=(0,i.EZ)(e),t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(o),r}function H(e){return 2===e&&null!=(0,r.bU)(e).fenceSync}function K(e,n){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&o.ZSL.assert("complex64"!==e.dtype,(()=>`${n} does not support complex64 tensors in the WebGL backend.`))}))}}}]);