/*! For license information please see chunk.c5d113dcd7dfe49fbc42.js.LICENSE.txt */
"use strict";(self.webpackChunkai_workout_assistant=self.webpackChunkai_workout_assistant||[]).push([[504],{68712:(e,t,n)=>{n.d(t,{W:()=>s});var r=n(45119);function s(e,t,n,s,a,i){null==s&&(s=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=e.shape[0];return n=Math.min(n,o),r.vA(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`)),r.vA(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),r.vA(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),r.vA(1===t.rank,(()=>"scores must be a 1D tensor")),r.vA(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),r.vA(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:s,scoreThreshold:a,softNmsSigma:i}}},92596:(e,t,n)=>{n.d(t,{x:()=>y});var r=n(28189),s=n(45119),a=n(4888),i=n(21078),o=n(41938),l=n(57436),u=n(70929),c=n(98990),h=n(62302),d=n(45702),p=n(79348),f=n(45793),m=n(83791);function g(e,t,n=null){if(0===e.rank)return(0,a.t)(e);if(1!==e.rank&&null===n)return g((0,h.t)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,m.c)((0,a.t)(e),n);if(t===1/0)return(0,o.T)((0,a.t)(e),n);if(t===-1/0)return(0,l.j)((0,a.t)(e),n);if("euclidean"===t||2===t)return(0,p.R)((0,m.c)((0,c.n)((0,a.t)(e),(0,d.d)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,o.T)((0,m.c)((0,a.t)(e),n[0]),n[1]-1);if(t===1/0)return(0,o.T)((0,m.c)((0,a.t)(e),n[1]),n[0]);if(t===-1/0)return(0,l.j)((0,m.c)((0,a.t)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,p.R)((0,m.c)((0,f.E)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const y=(0,u.op)({norm_:function(e,t="euclidean",n=null,a=!1){const o=g(e=(0,r.YT)(e,"x","norm"),t,n);let l=o.shape;if(a){const t=(0,s.Y6)(n,e.shape);l=i.SM(o.shape,t)}return(0,h.t)(o,l)}})},42118:(e,t,n)=>{n.d(t,{E:()=>l});var r=n(67897),s=n(15441),a=n(30565),i=n(28189),o=n(62198);const l=(0,n(70929).op)({notEqual_:function(e,t){let n=(0,i.YT)(e,"a","notEqual","string_or_numeric"),l=(0,i.YT)(t,"b","notEqual","string_or_numeric");[n,l]=(0,a.h0)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.ylV,u)}})},61411:(e,t,n)=>{n.d(t,{S:()=>o});var r=n(67897),s=n(45119),a=n(37148),i=n(42855);function o(e,t="float32"){if((0,s.SA)(e),"complex64"===t){const t=o(e,"float32"),n=(0,i.U)(e,"float32");return(0,a.f)(t,n)}const n=(0,s.FZ)((0,s.Ze)(e),t);return r.T2.makeTensor(n,e,t)}},70929:(e,t,n)=>{n.d(t,{B:()=>a,op:()=>i});var r=n(67897),s=n(45119);const a="__op";function i(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const i=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=a;const o=(...e)=>{r.T2.startScope(n);try{const t=i(...e);return(0,s.yL)(t)&&console.error("Cannot return a Promise inside of tidy."),r.T2.endScope(t),t}catch(e){throw r.T2.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},23379:(e,t,n)=>{n.d(t,{BTT:()=>rt.B,tnl:()=>r.t,HQu:()=>s.H,FqL:()=>a.F,WQq:()=>i.W,QiD:()=>o.Q,Q7R:()=>l.Q,bzn:()=>u.b,FLi:()=>c.F,XRg:()=>h.X,qRo:()=>d.q,yHs:()=>p.y,rYl:()=>f.r,FPz:()=>m.F,rfv:()=>g.r,$jT:()=>y.$,sub:()=>b.s,lZX:()=>w.l,$v7:()=>T.$,BFc:()=>A.B,kSi:()=>S.k,T5N:()=>E.T,GTe:()=>v.G,HbZ:()=>$.H,ftb:()=>qn.f,ROE:()=>k.R,hOW:()=>x.h,ra8:()=>_.r,wgE:()=>M.w,mkO:()=>I.m,zQh:()=>N.z,o8B:()=>R.o,faB:()=>D.f,xWs:()=>Y.x,I1m:()=>P.I,RPU:()=>F.R,O5O:()=>W.O,P1l:()=>G.P,kA9:()=>O.k,Xtf:()=>K.X,wX9:()=>V.w,IPL:()=>z.I,jIJ:()=>q.j,gnS:()=>C.g,yIG:()=>U.y,_jP:()=>Jn,Lp0:()=>B.L,rCv:()=>Z.r,aOp:()=>L.a,Rj8:()=>j.R,Gl3:()=>H.G,smy:()=>Q.s,X7t:()=>X.X,y4m:()=>J.y,ek5:()=>ee.e,Omf:()=>te.O,EZY:()=>Qn.E,_3C:()=>ne._,Pqc:()=>re.P,FJY:()=>Xn,LCg:()=>se.L,Y12:()=>ae.Y,p4S:()=>ie.p,oNF:()=>oe.o,UG6:()=>le.U,IYd:()=>ue.I,y5U:()=>ce.y,hVP:()=>an,GSj:()=>he.G,RIf:()=>de.R,wh_:()=>pe.w,cZk:()=>tr,kgh:()=>fe.k,SY9:()=>Hn.S,rhj:()=>me.r,DQN:()=>ge.D,KGM:()=>on,ngS:()=>ye.n,Slp:()=>Vr,U4u:()=>er.U,ggX:()=>ln,MIs:()=>be.M,EN4:()=>we.E,yrW:()=>ve.y,H8d:()=>Te.H,M7h:()=>Ae.M,InN:()=>Se.I,mPL:()=>zr,mT8:()=>Ee.m,Kgs:()=>$e.K,Rm2:()=>ke.R,Kko:()=>xe.K,nqI:()=>_e.n,HPB:()=>Me.H,VZ:()=>Ie.V,n76:()=>Ne.n,NSZ:()=>Re.N,ztW:()=>De.z,rxB:()=>Ye.r,YYh:()=>qr,yzS:()=>Pe.y,NoW:()=>Fe.N,T9B:()=>We.T,jgi:()=>Ge.j,NYV:()=>Oe.e,RO:()=>Ke.R,PhQ:()=>Ve.P,i2o:()=>ze.i,OYQ:()=>qe.O,jkA:()=>Ce.j,BpO:()=>Ue.B,FFZ:()=>Be.F,ziu:()=>Ze.z,Clk:()=>Le.C,CRk:()=>Bn.C,lKK:()=>je.l,YDF:()=>He.Y,OjQ:()=>Qe.O,HZy:()=>Xe.H,xbf:()=>Un.x,Ec:()=>Je.E,Mw0:()=>st,SaS:()=>at.S,P61:()=>it,op:()=>rt.op,X4o:()=>ut,eVF:()=>ct.e,BZs:()=>ht,grY:()=>dt,XHu:()=>pt,WLX:()=>ft,dzn:()=>yt,n7C:()=>bt.n,NsG:()=>wt.N,yyV:()=>vt.y,_eU:()=>Tt,whe:()=>At,iyU:()=>St,Q0_:()=>Et,_9M:()=>$t,pR9:()=>xt,FE$:()=>_t,m0H:()=>Mt,YeY:()=>It.Y,y17:()=>Nt.y,xav:()=>Rt.x,VOZ:()=>Dt,VVh:()=>Yt.V,j__:()=>Pt.j,tQQ:()=>lt.t,BEg:()=>Ft.B,QD2:()=>Wt,LMr:()=>Gt,I2l:()=>Ot,JYU:()=>Kt,z8$:()=>dn,LIG:()=>Vt.L,Z$r:()=>zt.Z,d_2:()=>qt.d,NFr:()=>Ln,sZg:()=>Gn.s,WfX:()=>Ct,wdz:()=>Ut,F12:()=>Zt,ry7:()=>Lt.r,_SZ:()=>jt,vPA:()=>Kr,F8e:()=>Ht.F,L0l:()=>Qt.L,dik:()=>Xt.d,Q$M:()=>Jt,zAd:()=>en,wck:()=>tn,R0O:()=>nn,Vs9:()=>rn,lw0:()=>sn.l,eDJ:()=>gt.e,lMo:()=>Cr,Zhr:()=>jn,lOn:()=>Or,lDo:()=>un.l,RZD:()=>pn.R,EwI:()=>fn.E,Pbu:()=>mn.P,r2V:()=>gn.r,t$z:()=>yn.t,PMw:()=>bn.P,Ym9:()=>wn,YjP:()=>Ur,jbE:()=>vn.j,czq:()=>Tn.c,Mlm:()=>An,ymU:()=>Sn.y,OEK:()=>En.O,tGX:()=>$n.t,KtR:()=>kn.K,$_$:()=>xn.$,g9W:()=>Mn,Lpo:()=>In,yxw:()=>Nn,Vsq:()=>Rn.V,rfw:()=>Dn,mgz:()=>Cn.m,efE:()=>Yn,AmM:()=>Pn,zAU:()=>Fn.z,K$i:()=>Wn.K,rni:()=>On,bvq:()=>Kn,_M9:()=>Vn._,YJN:()=>zn.Y,Ul9:()=>cn.U,POl:()=>hn.P});var r=n(4888),s=n(12804),a=n(37558),i=n(37523),o=n(16054),l=n(12307),u=n(89326),c=n(10897),h=n(54339),d=n(66841),p=n(50269),f=n(29580),m=n(21404),g=n(63774),y=n(53909),b=n(53855),w=n(69906),v=n(69772),T=n(9160),A=n(13620),S=n(76241),E=n(27874),$=n(40758),k=n(17367),x=n(63567),_=n(448),M=n(29809),I=n(30855),N=n(96928),R=n(70125),D=n(37148),Y=n(25030),P=n(46520),F=n(19879),W=n(55530),G=n(60569),O=n(3701),K=n(28794),V=n(41106),z=n(90167),q=n(41655),C=n(99907),U=n(27451),B=n(10302),Z=n(76808),L=n(77974),j=n(31216),H=n(10676),Q=n(10601),X=n(93002),J=n(89359),ee=n(919),te=n(69759),ne=n(79853),re=n(83416),se=n(13020),ae=n(95207),ie=n(44881),oe=n(8631),le=n(8710),ue=n(40517),ce=n(53621),he=n(96111),de=n(15606),pe=n(88991),fe=n(48229),me=n(62058),ge=n(13337),ye=n(35040),be=n(68318),we=n(33454),ve=n(6300),Te=n(66919),Ae=n(61303),Se=n(56508),Ee=n(46545),$e=n(93531),ke=n(44010),xe=n(12015),_e=n(95645),Me=n(97991),Ie=n(13330),Ne=n(13789),Re=n(89881),De=n(9879),Ye=n(19925),Pe=n(80462),Fe=n(65703),We=n(41938),Ge=n(86999),Oe=n(14349),Ke=n(45243),Ve=n(30178),ze=n(12611),qe=n(15027),Ce=n(57436),Ue=n(12644),Be=n(66567),Ze=n(60152),Le=n(91413),je=n(9258),He=n(7843),Qe=n(71781),Xe=n(96522),Je=n(42118),et=n(67897),tt=n(15441),nt=n(28189),rt=n(70929);const st=(0,rt.op)({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:(0,nt.YT)(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return et.T2.runKernel(tt.urI,a,i)}});var at=n(61411);const it=(0,rt.op)({onesLike_:function(e){const t={x:(0,nt.YT)(e,"x","onesLike")};return et.T2.runKernel(tt.LWX,t)}});var ot=n(45119),lt=n(62302);const ut=(0,rt.op)({outerProduct_:function(e,t){const n=(0,nt.YT)(e,"v1","outerProduct"),r=(0,nt.YT)(t,"v2","outerProduct");ot.vA(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=(0,lt.t)(n,[-1,1]),a=(0,lt.t)(r,[1,-1]);return(0,Fe.N)(s,a)}});var ct=n(65661);const ht=(0,rt.op)({pad1d_:function(e,t,n=0){return(0,ot.vA)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),(0,ct.e)(e,[t],n)}}),dt=(0,rt.op)({pad2d_:function(e,t,n=0){return(0,ot.vA)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,ct.e)(e,t,n)}}),pt=(0,rt.op)({pad3d_:function(e,t,n=0){return(0,ot.vA)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,ct.e)(e,t,n)}}),ft=(0,rt.op)({pad4d_:function(e,t,n=0){return(0,ot.vA)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,ct.e)(e,t,n)}});var mt=n(47195),gt=n(10776);const yt=(0,rt.op)({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=(0,nt.YT)(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=(0,lt.t)(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ot.vA(mt.G0(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=mt.E6(l.shape,t,a,s,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),s=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],s[t]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t]));return[t.map(((e,t)=>[r[t],o[t]])),t.map(((e,t)=>[0,i[t]]))]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",b=p?l:(0,gt.e)(l,h,f),w=("avg"===n?()=>(0,y.$)(b,t,a,g,i):()=>(0,Ge.j)(b,t,a,g,i))(),T=p?w:(0,v.G)(w,h,m);return u?(0,lt.t)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}});var bt=n(98990),wt=n(64394),vt=n(75295);const Tt=(0,rt.op)({prod_:function(e,t=null,n=!1){let r=(0,nt.YT)(e,"x","prod");"bool"===r.dtype&&(r=(0,M.w)(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return et.T2.runKernel(tt.kdj,s,a)}}),At=(0,rt.op)({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>(0,nt.YT)(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:(0,nt.YT)(t,"paramsDenseValues","raggedGather"),indices:(0,nt.YT)(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=et.T2.runKernel(tt.oJ2,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}}),St=(0,rt.op)({raggedRange_:function(e,t,n){const r=(0,nt.YT)(e,"starts","raggedRange"),s={starts:r,limits:(0,nt.YT)(t,"limits","raggedRange",r.dtype),deltas:(0,nt.YT)(n,"deltas","raggedRange",r.dtype)},a=et.T2.runKernel(tt.CQC,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),Et=(0,rt.op)({raggedTensorToTensor_:function(e,t,n,r,s){const a=(0,nt.YT)(e,"shape","raggedTensorToTensor","int32"),i=(0,nt.YT)(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:(0,nt.YT)(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>(0,nt.YT)(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:s};return et.T2.runKernel(tt.mH5,o,l)}}),$t=(0,rt.op)({rand_:function(e,t,n){(0,ot.SA)(e);const r=(0,ot.Ze)(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return et.T2.makeTensor(s,e,n)}});var kt=n(89748);const xt=(0,rt.op)({randomGamma_:function(e,t,n=1,r="float32",s){if((0,ot.SA)(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new kt.XA(t,n,r,s),i=(0,_.r)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),_t=(0,rt.op)({randomNormal_:function(e,t=0,n=1,r,s){if((0,ot.SA)(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new kt.ai(t,n,r,!1,s),i=(0,_.r)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Mt=(0,rt.op)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return _t(e,0,1,t,n)}});var It=n(79546),Nt=n(44645),Rt=n(1902);const Dt=(0,rt.op)({reciprocal_:function(e){const t={x:(0,nt.YT)(e,"x","reciprocal")};return et.T2.runKernel(tt.huO,t)}});var Yt=n(90112),Pt=n(83732),Ft=n(53262);const Wt=(0,rt.op)({reverse1d_:function(e){const t=(0,nt.YT)(e,"x","reverse");return ot.vA(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),(0,Ft.B)(t,0)}}),Gt=(0,rt.op)({reverse2d_:function(e,t){const n=(0,nt.YT)(e,"x","reverse");return ot.vA(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),(0,Ft.B)(n,t)}}),Ot=(0,rt.op)({reverse3d_:function(e,t){const n=(0,nt.YT)(e,"x","reverse");return ot.vA(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),(0,Ft.B)(n,t)}}),Kt=(0,rt.op)({reverse4d_:function(e,t){const n=(0,nt.YT)(e,"x","reverse");return ot.vA(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),(0,Ft.B)(n,t)}});var Vt=n(25912),zt=n(17820),qt=n(45702);const Ct=(0,rt.op)({selu_:function(e){const t={x:(0,nt.YT)(e,"x","selu")};return et.T2.runKernel(tt.u$b,t)}}),Ut=(0,rt.op)({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=(0,nt.YT)(e,"x","separableConv2d"),l=(0,nt.YT)(t,"depthwiseFilter","separableConv2d"),u=(0,nt.YT)(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=(0,lt.t)(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ot.vA(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),ot.vA(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),ot.vA(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),ot.vA(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),ot.vA(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];ot.vA(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=(0,H.G)(c,l,r,s,i,a),m=(0,K.X)(f,u,1,"valid",i);return h?(0,lt.t)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var Bt=n(50259);const Zt=async function(e,t){const n=(0,nt.YT)(e,"x","setdiff1d"),r=(0,nt.YT)(t,"y","setdiff1d");ot.vA(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),ot.vA(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),ot.vA(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const l=new Bt.yl([o],n.dtype),u=new Bt.yl([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(l.values[t]=s[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]};var Lt=n(28968);const jt=(0,rt.op)({sign_:function(e){const t={x:(0,nt.YT)(e,"x","sign")};return et.T2.runKernel(tt.YVe,t)}});var Ht=n(33726),Qt=n(58276),Xt=n(17986);const Jt=(0,rt.op)({slice1d_:function(e,t,n){const r=(0,nt.YT)(e,"x","slice1d");return ot.vA(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),(0,Xt.d)(r,[t],[n])}}),en=(0,rt.op)({slice2d_:function(e,t,n){const r=(0,nt.YT)(e,"x","slice2d");return ot.vA(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),(0,Xt.d)(r,t,n)}}),tn=(0,rt.op)({slice3d_:function(e,t,n){const r=(0,nt.YT)(e,"x","slice3d");return ot.vA(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),(0,Xt.d)(r,t,n)}}),nn=(0,rt.op)({slice4d_:function(e,t,n){const r=(0,nt.YT)(e,"x","slice4d");return ot.vA(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),(0,Xt.d)(r,t,n)}}),rn=(0,rt.op)({softmax_:function(e,t=-1){const n=(0,nt.YT)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return et.T2.runKernel(tt.rFG,r,s)}});var sn=n(66030);const an=(0,rt.op)({fft_:function(e){(0,ot.vA)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return et.T2.runKernel(tt.rGP,t)}}),on=(0,rt.op)({ifft_:function(e){(0,ot.vA)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return et.T2.runKernel(tt.OAQ,t)}}),ln=(0,rt.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=(0,lt.t)(e,[n,t]);r=on(s)}else{const s=[n,2*(t-1)],a=(0,lt.t)((0,Rt.x)(e),[n,t]),i=(0,lt.t)((0,ye.n)(e),[n,t]),o=(0,Ft.B)((0,Xt.d)(a,[0,1],[n,t-2]),1),l=(0,je.l)((0,Ft.B)((0,Xt.d)(i,[0,1],[n,t-2]),1),(0,qt.d)(-1)),u=(0,Y.x)([a,o],1),c=(0,Y.x)([i,l],1),h=(0,lt.t)((0,D.f)(u,c),[s[0],s[1]]);r=on(h)}if(r=(0,Rt.x)(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=(0,lt.t)(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});var un=n(66512),cn=n(42855),hn=n(55537);const dn=(0,rt.op)({rfft_:function(e,t){(0,ot.vA)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=(0,Xt.d)(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=(0,Y.x)([e,(0,cn.U)(r)],e.shape.length-1),n=t}else s=e;const a=(0,hn.P)(s),i=(0,lt.t)((0,D.f)(s,a),[r,n]),o=an(i),l=Math.floor(n/2)+1,u=(0,Rt.x)(o),c=(0,ye.n)(o),h=(0,un.l)(u,[l,n-l],u.shape.length-1),d=(0,un.l)(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,(0,lt.t)((0,D.f)(h[0],d[0]),p)}});var pn=n(79348),fn=n(45793),mn=n(53427),gn=n(5932),yn=n(54268),bn=n(10700);const wn=(0,rt.op)({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const u={x:(0,nt.YT)(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return et.T2.runKernel(tt.UcO,u,c)}});var vn=n(77126),Tn=n(83791);const An=(0,rt.op)({tan_:function(e){const t={x:(0,nt.YT)(e,"x","tan","float32")};return et.T2.runKernel(tt.oFs,t)}});var Sn=n(57311),En=n(74027),$n=n(62018),kn=n(18941),xn=n(42768),_n=n(19171);function Mn(e,t,n){if((0,ot.HO)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=(0,nt.MZ)(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,_n.Q)(e,t,r,n)}function In(e,t,n){if((0,ot.HO)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=(0,nt.MZ)(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,_n.Q)(e,t,r,n)}function Nn(e,t,n){if((0,ot.HO)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=(0,nt.MZ)(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,(0,_n.Q)(e,t,r,n)}var Rn=n(64826);const Dn=(0,rt.op)({topk_:function(e,t=1,n=!0){const r=(0,nt.YT)(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=et.T2.runKernel(tt.TBb,a,i);return{values:o,indices:l}}}),Yn=(0,rt.op)({truncatedNormal_:function(e,t=0,n=1,r,s){if((0,ot.SA)(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new kt.ai(t,n,r,!0,s),i=(0,_.r)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Pn=(0,rt.op)({unique_:function(e,t=0){const n=(0,nt.YT)(e,"x","unique","string_or_numeric");(0,ot.vA)(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=et.T2.runKernel(tt.EwU,r,s);return{values:a,indices:i}}});var Fn=n(97706),Wn=n(67261),Gn=n(79120);function On(e,t){return(0,Gn.s)(e,t,"right")}function Kn(e,t=!0,n,r){return et.T2.makeVariable(e,t,n,r)}var Vn=n(12151),zn=n(44271),qn=n(33007),Cn=n(7703),Un=n(92596),Bn=n(65772),Zn=n(26170);const Ln=(0,rt.op)({scatterND_:function(e,t,n){(0,ot.SA)(n);const r=(0,nt.YT)(e,"indices","scatterND","int32"),s=(0,nt.YT)(t,"updates","scatterND");Zn.TT(s,r,n);const a={indices:r,updates:s},i={shape:n};return et.T2.runKernel(tt.pJc,a,i)}}),jn=(0,rt.op)({sparseToDense_:function(e,t,n,r=0){(0,ot.SA)(n);const s=(0,nt.YT)(e,"sparseIndices","sparseToDense","int32"),a=(0,nt.YT)(t,"sparseValues","sparseToDense","string_or_numeric"),i=(0,nt.YT)(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return et.T2.runKernel(tt.jgd,o,l)}});var Hn=n(55598),Qn=n(19457);function Xn(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Jn(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return(0,$n.t)(s,"float32")}var er=n(5323),tr=n(2956);const nr=(0,rt.op)({hammingWindow_:function(e){return Jn(e,.54,.46)}}),rr=(0,rt.op)({hannWindow_:function(e){return Jn(e,.5,.5)}}),sr=(0,rt.op)({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push((0,Xt.d)(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=(0,Y.x)([(0,Xt.d)(e,a,t-r),(0,he.G)([r],s)]);i.push(o),a+=n}return 0===i.length?(0,kn.K)([],[0,t]):(0,lt.t)((0,Y.x)(i),[i.length,t])}}),ar=(0,rt.op)({stft_:function(e,t,n,r,s=rr){null==r&&(r=Xn(t));const a=sr(e,t,n),i=(0,je.l)(a,s(t));return dn(i,r)}});var ir=n(31951),or=n(73866),lr=n(41477),ur=n(64658),cr=n(56248),hr=n(70215),dr=n(95634),pr=n(7425),fr=n(84305),mr=n(5902),gr=n(44711),yr=n(42954),br=n(80525),wr=n(1242),vr=n(36359),Tr=n(76304),Ar=n(1211),Sr=n(89535),Er=n(69533),$r=n(39417),kr=n(70327),xr=n(40718),_r=n(21780),Mr=n(22150),Ir=n(58687),Nr=n(69881);const Rr=(0,rt.op)({sparseFillEmptyRows_:function(e,t,n,r){const s=(0,nt.YT)(e,"indices","sparseFillEmptyRows","int32"),a=(0,nt.YT)(t,"values","sparseFillEmptyRows"),i=(0,nt.YT)(n,"denseShape","sparseFillEmptyRows","int32"),o=(0,nt.YT)(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=et.T2.runKernel(tt.C8s,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),Dr=(0,rt.op)({sparseReshape_:function(e,t,n){const r=(0,nt.YT)(e,"inputIndices","sparseReshape","int32"),s=(0,nt.YT)(t,"inputShape","sparseReshape","int32"),a=(0,nt.YT)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=et.T2.runKernel(tt.BoJ,i);return{outputIndices:o[0],outputShape:o[1]}}}),Yr=(0,rt.op)({sparseSegmentMean_:function(e,t,n){const r=(0,nt.YT)(e,"data","sparseSegmentMean"),s=(0,nt.YT)(t,"indices","sparseSegmentMean","int32"),a=(0,nt.YT)(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return et.T2.runKernel(tt.L6G,i)}}),Pr=(0,rt.op)({sparseSegmentSum_:function(e,t,n){const r=(0,nt.YT)(e,"data","sparseSegmentSum"),s=(0,nt.YT)(t,"indices","sparseSegmentSum","int32"),a=(0,nt.YT)(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return et.T2.runKernel(tt.DvZ,i)}}),Fr=(0,rt.op)({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=(0,nt.YT)(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=(0,nt.YT)(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},d=et.T2.runKernel(tt.YAb,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}}),Wr=(0,rt.op)({stringSplit_:function(e,t,n=!0){const r=(0,nt.YT)(e,"input","stringSplit","string"),s=(0,nt.YT)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=et.T2.runKernel(tt.iW0,i,a);return{indices:o[0],values:o[1],shape:o[2]}}}),Gr=(0,rt.op)({stringToHashBucketFast_:function(e,t){const n=(0,nt.YT)(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return et.T2.runKernel(tt.$jE,s,r)}}),Or={fft:an,ifft:on,rfft:dn,irfft:ln},Kr={hammingWindow:nr,hannWindow:rr,frame:sr,stft:ar},Vr={flipLeftRight:or.n,grayscaleToRGB:lr.C,resizeNearestNeighbor:yr.b,resizeBilinear:gr.v,rotateWithOffset:ur.x,cropAndResize:ir.C,nonMaxSuppression:cr.L,nonMaxSuppressionAsync:hr.z,nonMaxSuppressionWithScore:dr.f,nonMaxSuppressionWithScoreAsync:pr.l,nonMaxSuppressionPadded:fr.H,nonMaxSuppressionPaddedAsync:mr.R,threshold:br.E,transform:wr.p},zr={bandPart:vr.x,gramSchmidt:Tr.i,qr:Ar.qr},qr={absoluteDifference:Sr.n,computeWeightedLoss:Er.M,cosineDistance:$r.l,hingeLoss:kr.Z,huberLoss:xr.c,logLoss:_r._,meanSquaredError:Mr.b,sigmoidCrossEntropy:Ir.k,softmaxCrossEntropy:Nr.C},Cr={sparseFillEmptyRows:Rr,sparseReshape:Dr,sparseSegmentMean:Yr,sparseSegmentSum:Pr},Ur={stringNGrams:Fr,stringSplit:Wr,stringToHashBucketFast:Gr}},9951:(e,t,n)=>{n.r(t),n.d(t,{OP_SCOPE_SUFFIX:()=>r.BTT,abs:()=>r.tnl,acos:()=>r.HQu,acosh:()=>r.FqL,add:()=>r.WQq,addN:()=>r.QiD,all:()=>r.Q7R,any:()=>r.bzn,argMax:()=>r.FLi,argMin:()=>r.XRg,asin:()=>r.qRo,asinh:()=>r.yHs,atan:()=>r.rYl,atan2:()=>r.FPz,atanh:()=>r.rfv,avgPool:()=>r.$jT,avgPool3d:()=>r.sub,basicLSTMCell:()=>r.lZX,batchNorm:()=>r.$v7,batchNorm2d:()=>r.BFc,batchNorm3d:()=>r.kSi,batchNorm4d:()=>r.T5N,batchToSpaceND:()=>r.GTe,bincount:()=>r.HbZ,booleanMaskAsync:()=>r.ftb,broadcastArgs:()=>r.ROE,broadcastTo:()=>r.hOW,buffer:()=>r.ra8,cast:()=>r.wgE,ceil:()=>r.mkO,clipByValue:()=>r.zQh,clone:()=>r.o8B,complex:()=>r.faB,concat:()=>r.xWs,concat1d:()=>r.I1m,concat2d:()=>r.RPU,concat3d:()=>r.O5O,concat4d:()=>r.P1l,conv1d:()=>r.kA9,conv2d:()=>r.Xtf,conv2dTranspose:()=>r.wX9,conv3d:()=>r.IPL,conv3dTranspose:()=>r.jIJ,cos:()=>r.gnS,cosh:()=>r.yIG,cosineWindow:()=>r._jP,cumprod:()=>r.Lp0,cumsum:()=>r.rCv,denseBincount:()=>r.aOp,depthToSpace:()=>r.Rj8,depthwiseConv2d:()=>r.Gl3,diag:()=>r.smy,dilation2d:()=>r.X7t,div:()=>r.y4m,divNoNan:()=>r.ek5,dot:()=>r.Omf,dropout:()=>r.EZY,einsum:()=>r._3C,elu:()=>r.Pqc,enclosingPowerOfTwo:()=>r.FJY,equal:()=>r.LCg,erf:()=>r.Y12,euclideanNorm:()=>r.p4S,exp:()=>r.oNF,expandDims:()=>r.UG6,expm1:()=>r.IYd,eye:()=>r.y5U,fft:()=>r.hVP,fill:()=>r.GSj,floor:()=>r.RIf,floorDiv:()=>r.wh_,fused:()=>r.cZk,gather:()=>r.kgh,gatherND:()=>r.SY9,greater:()=>r.rhj,greaterEqual:()=>r.DQN,ifft:()=>r.KGM,imag:()=>r.ngS,image:()=>r.Slp,inTopKAsync:()=>r.U4u,irfft:()=>r.ggX,isFinite:()=>r.MIs,isInf:()=>r.EN4,isNaN:()=>r.yrW,leakyRelu:()=>r.H8d,less:()=>r.M7h,lessEqual:()=>r.InN,linalg:()=>r.mPL,linspace:()=>r.mT8,localResponseNormalization:()=>r.Kgs,log:()=>r.Rm2,log1p:()=>r.Kko,logSigmoid:()=>r.nqI,logSoftmax:()=>r.HPB,logSumExp:()=>r.VZ,logicalAnd:()=>r.n76,logicalNot:()=>r.NSZ,logicalOr:()=>r.ztW,logicalXor:()=>r.rxB,losses:()=>r.YYh,lowerBound:()=>r.yzS,matMul:()=>r.NoW,max:()=>r.T9B,maxPool:()=>r.jgi,maxPool3d:()=>r.NYV,maxPoolWithArgmax:()=>r.RO,maximum:()=>r.PhQ,mean:()=>r.i2o,meshgrid:()=>r.OYQ,min:()=>r.jkA,minimum:()=>r.BpO,mirrorPad:()=>r.FFZ,mod:()=>r.ziu,moments:()=>r.Clk,movingAverage:()=>r.CRk,mul:()=>r.lKK,multiRNNCell:()=>r.YDF,multinomial:()=>r.OjQ,neg:()=>r.HZy,norm:()=>r.xbf,notEqual:()=>r.Ec,oneHot:()=>r.Mw0,ones:()=>r.SaS,onesLike:()=>r.P61,op:()=>r.op,outerProduct:()=>r.X4o,pad:()=>r.eVF,pad1d:()=>r.BZs,pad2d:()=>r.grY,pad3d:()=>r.XHu,pad4d:()=>r.WLX,pool:()=>r.dzn,pow:()=>r.n7C,prelu:()=>r.NsG,print:()=>r.yyV,prod:()=>r._eU,raggedGather:()=>r.whe,raggedRange:()=>r.iyU,raggedTensorToTensor:()=>r.Q0_,rand:()=>r._9M,randomGamma:()=>r.pR9,randomNormal:()=>r.FE$,randomStandardNormal:()=>r.m0H,randomUniform:()=>r.YeY,range:()=>r.y17,real:()=>r.xav,reciprocal:()=>r.VOZ,relu:()=>r.VVh,relu6:()=>r.j__,reshape:()=>r.tQQ,reverse:()=>r.BEg,reverse1d:()=>r.QD2,reverse2d:()=>r.LMr,reverse3d:()=>r.I2l,reverse4d:()=>r.JYU,rfft:()=>r.z8$,round:()=>r.LIG,rsqrt:()=>r.Z$r,scalar:()=>r.d_2,scatterND:()=>r.NFr,searchSorted:()=>r.sZg,selu:()=>r.WfX,separableConv2d:()=>r.wdz,setdiff1dAsync:()=>r.F12,sigmoid:()=>r.ry7,sign:()=>r._SZ,signal:()=>r.vPA,sin:()=>r.F8e,sinh:()=>r.L0l,slice:()=>r.dik,slice1d:()=>r.Q$M,slice2d:()=>r.zAd,slice3d:()=>r.wck,slice4d:()=>r.R0O,softmax:()=>r.Vs9,softplus:()=>r.lw0,spaceToBatchND:()=>r.eDJ,sparse:()=>r.lMo,sparseToDense:()=>r.Zhr,spectral:()=>r.lOn,split:()=>r.lDo,sqrt:()=>r.RZD,square:()=>r.EwI,squaredDifference:()=>r.Pbu,squeeze:()=>r.r2V,stack:()=>r.t$z,step:()=>r.PMw,stridedSlice:()=>r.Ym9,string:()=>r.YjP,sub:()=>r.jbE,sum:()=>r.czq,tan:()=>r.Mlm,tanh:()=>r.ymU,tensor:()=>r.OEK,tensor1d:()=>r.tGX,tensor2d:()=>r.KtR,tensor3d:()=>r.$_$,tensor4d:()=>r.g9W,tensor5d:()=>r.Lpo,tensor6d:()=>r.yxw,tile:()=>r.Vsq,topk:()=>r.rfw,transpose:()=>r.mgz,truncatedNormal:()=>r.efE,unique:()=>r.AmM,unsortedSegmentSum:()=>r.zAU,unstack:()=>r.K$i,upperBound:()=>r.rni,variable:()=>r.bvq,where:()=>r._M9,whereAsync:()=>r.YJN,zeros:()=>r.Ul9,zerosLike:()=>r.POl});var r=n(23379)},65661:(e,t,n)=>{n.d(t,{e:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({pad_:function(e,t,n=0){const i=(0,a.YT)(e,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},l={x:i};return r.T2.runKernel(s.ODT,l,o)}})},98990:(e,t,n)=>{n.d(t,{n:()=>o});var r=n(67897),s=n(15441),a=n(30565),i=n(28189);const o=(0,n(70929).op)({pow_:function(e,t){let n=(0,i.YT)(e,"base","pow"),o=(0,i.YT)(t,"exp","pow");[n,o]=(0,a.h0)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.pyJ,l)}})},64394:(e,t,n)=>{n.d(t,{N:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({prelu_:function(e,t){const n={x:(0,a.YT)(e,"x","prelu"),alpha:(0,a.YT)(t,"alpha","prelu")};return r.T2.runKernel(s.Ncv,n)}})},75295:(e,t,n)=>{function r(e,t=!1){console.log(e.toString(t))}n.d(t,{y:()=>r})},30429:(e,t,n)=>{var r;function s(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function a(e){const t={FIRST_DIM_SIZE:r.FIRST_DIM_SIZE,VALUE_ROWIDS:r.VALUE_ROWIDS,ROW_LENGTHS:r.ROW_LENGTHS,ROW_SPLITS:r.ROW_SPLITS,ROW_LIMITS:r.ROW_LIMITS,ROW_STARTS:r.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function i(e){return 0===e.length?0:e[0]===r.FIRST_DIM_SIZE?e.length-1:e.length}function o(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}n.d(t,{Dw:()=>i,U0:()=>a,mP:()=>o,tl:()=>r,z4:()=>s}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(r||(r={}))},89748:(e,t,n)=>{n.d(t,{XA:()=>a,ai:()=>s,yU:()=>i});var r=n(7391);class s{constructor(e,t,n,s,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=a||Math.random();this.random=r.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class a{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const i=a||Math.random();this.randu=r.alea(i.toString()),this.randn=new s(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class i{constructor(e=0,t=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=r.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},79546:(e,t,n)=>{n.d(t,{Y:()=>o});var r=n(45119),s=n(448),a=n(70929),i=n(89748);const o=(0,a.op)({randomUniform_:function(e,t=0,n=1,a="float32",o){(0,r.SA)(e);const l=(0,s.r)(e,a),u=new i.yU(t,n,null,o);for(let e=0;e<l.values.length;e++)l.values[e]=u.nextValue();return l.toTensor()}})},44645:(e,t,n)=>{n.d(t,{y:()=>a});var r=n(67897),s=n(15441);function a(e,t,n=1,a="float32"){if(0===n)throw new Error("Cannot have a step of zero");const i={start:e,stop:t,step:n,dtype:a};return r.T2.runKernel(s.Q6t,{},i)}},1902:(e,t,n)=>{n.d(t,{x:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({real_:function(e){const t={input:(0,a.YT)(e,"input","real")};return r.T2.runKernel(s.LRy,t)}})},29827:(e,t,n)=>{n.d(t,{m:()=>s,x:()=>a});var r=n(45119);const s=30;function a(e){return e<=s?e:(0,r.lK)(e,Math.floor(Math.sqrt(e)))}},90112:(e,t,n)=>{n.d(t,{V:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({relu_:function(e){const t={x:(0,a.YT)(e,"x","relu")};return r.T2.runKernel(s.fUj,t)}})},83732:(e,t,n)=>{n.d(t,{j:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({relu6_:function(e){const t={x:(0,a.YT)(e,"x","relu6")};return r.T2.runKernel(s.P_L,t)}})},62302:(e,t,n)=>{n.d(t,{t:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({reshape_:function(e,t){const n={x:(0,a.YT)(e,"x","reshape","string_or_numeric")},i={shape:t};return r.T2.runKernel(s.R23,n,i)}})},53262:(e,t,n)=>{n.d(t,{B:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({reverse_:function(e,t){const n={x:(0,a.YT)(e,"x","reverse")},i={dims:t};return r.T2.runKernel(s.D7i,n,i)}})},29192:(e,t,n)=>{function r(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}n.d(t,{H:()=>r})},25912:(e,t,n)=>{n.d(t,{L:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({round_:function(e){const t={x:(0,a.YT)(e,"x","round")};return r.T2.runKernel(s.hVg,t)}})},17820:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({rsqrt_:function(e){const t={x:(0,a.YT)(e,"x","rsqrt","float32")};return r.T2.runKernel(s.TOR,t)}})},45702:(e,t,n)=>{n.d(t,{d:()=>a});var r=n(89783),s=n(19171);function a(e,t){if(((0,r.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.isTypedArray)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,s.Q)(e,[],[],t)}},26170:(e,t,n)=>{n.d(t,{Ly:()=>s,TT:()=>a,l8:()=>i});var r=n(45119);function s(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function a(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}s(n,t,e)}function i(e,t,n){const s=t.shape.length,a=s>1?t.shape[s-1]:1,i=n.length;let o=1;for(let e=a;e<i;++e)o*=n[e];const l=a<1?1:a;return{sliceRank:a,numUpdates:(0,r.Ze)(t.shape)/l,sliceSize:o,strides:[...(0,r.Ur)(n.slice(0,a)),1],outputSize:(0,r.Ze)(n)}}},79120:(e,t,n)=>{n.d(t,{s:()=>c});var r=n(67897),s=n(15441),a=n(28189),i=n(45119),o=n(70929),l=n(62302);const u=2147483648,c=(0,o.op)({searchSorted_:function(e,t,n="left"){const o=(0,a.YT)(e,"sortedSequence","searchSorted"),c=(0,a.YT)(t,"values","searchSorted"),h=o.shape[o.shape.length-1],d=c.shape[c.shape.length-1],p=(0,l.t)(o,[-1,h]),f=(0,l.t)(c,[-1,d]);if(p.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(p.shape[0]!==f.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,i.Ze)(f.shape)>=u)throw new Error("values tensor size must less than 2147483648");if(p.shape[1]>=u)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${p.shape[1]}`);const m={sortedSequence:p,values:f},g={side:n};return r.T2.runKernel(s.uWl,m,g)}})},47516:(e,t,n)=>{n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>o,computeOutShape:()=>i,segOpComputeOptimalWindowSize:()=>a});var r=n(45119),s=n(29827);function a(e,t){let n,a=!1;for(e<=s.m?(n=e,a=!0):n=(0,r.lK)(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=(0,r.lK)(e,n+1);return n}function i(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function o(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}},28576:(e,t,n)=>{n.d(t,{X:()=>s,j:()=>r});const r=1.7580993408473768,s=1.0507009873554805},28968:(e,t,n)=>{n.d(t,{r:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({sigmoid_:function(e){const t={x:(0,a.YT)(e,"x","sigmoid","float32")};return r.T2.runKernel(s.vI1,t)}})},33726:(e,t,n)=>{n.d(t,{F:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({sin_:function(e){const t={x:(0,a.YT)(e,"x","sin","float32")};return r.T2.runKernel(s.hql,t)}})},58276:(e,t,n)=>{n.d(t,{L:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({sinh_:function(e){const t={x:(0,a.YT)(e,"x","sinh")};return r.T2.runKernel(s.J3C,t)}})},17986:(e,t,n)=>{n.d(t,{d:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({slice_:function(e,t,n){const i=(0,a.YT)(e,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");const o={x:i},l={begin:t,size:n};return r.T2.runKernel(s.JiE,o,l)}})},34969:(e,t,n)=>{n.r(t),n.d(t,{assertParamsValid:()=>i,computeFlatOffset:()=>w,computeOutShape:()=>l,getNormalizedAxes:()=>d,isSliceContinous:()=>b,maskToAxes:()=>o,parseSliceParams:()=>v,sliceInfo:()=>T,startForAxis:()=>g,startIndicesWithElidedDims:()=>p,stopForAxis:()=>y,stopIndicesWithElidedDims:()=>f,stridesForAxis:()=>m,stridesWithElidedDims:()=>u});var r=n(45119);const s=-2,a=-1;function i(e,t,n){const s=e.shape.length;r.vA(s===t.length,(()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)),r.vA(s===n.length,(()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`));for(let a=0;a<s;++a)r.vA(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${s}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function o(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function l(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function u(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function c(e,t,n){return n<=e?n:n-(t-1)}function h(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function d(e,t,n,r,s,a,i,o,l){const c=e.length;let h=new Array(c),d=new Array(c),b=new Array(c);if(t.length&&n>0){const l=t[0],c=n+1;h=p(i,l,c,r,e),d=f(o,l,c,s,e),b=u(a,l,c,e)}else for(let t=0;t<c;t++)h[t]=g(i,r,a,e,t,l),d[t]=y(o,s,a,e,t,l),b[t]=m(a,t,l);return{begin:h,end:d,strides:b}}function p(e,t,n,r,s){const a=[...s],i=h(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=c(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function f(e,t,n,s,a){const i=[...a],o=h(n,t);for(let r=0;r<i.length;r++)if(o.indexOf(r)>-1)i[r]=Number.MAX_SAFE_INTEGER;else{const a=c(t,n,r);let o=s[a];e&1<<a&&(o=Number.MAX_SAFE_INTEGER),i[r]=o}for(let e=0;e<i.length;e++){const t=a[e];i[e]<0&&(i[e]+=t),i[e]=r.qE(0,i[e],a[e])}return i}function m(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function g(e,t,n,s,a,i){let o=t[a];const l=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=s[a];return o<0&&(o+=u),o=r.qE(0,o,u-1),o}function y(e,t,n,s,a,i){let o=t[a];const l=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[a];return o<0&&(o+=u),o=l>0?r.qE(0,o,u):r.qE(-1,o,u-1),o}function b(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function w(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function v(e,t,n){let s;const a=e.shape.length;let i;return s="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),s.forEach((e=>{r.vA(-1!==e,(()=>"slice() does not support negative begin indexing."))})),i=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,i=i.map(((t,n)=>t>=0?t:(r.vA(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-s[n]))),[s,i]}function T(e,t,n,r,i,o,l,u,c){let h;if(null==r?(h=new Array(t.length),h.fill(1)):h=r,null!=l&&0!=(l&l-1))throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:h.slice(),beginMask:i,endMask:o,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:c};for(let e=0;e<p.dims;e++)d&&0!=(1<<e&u)&&p.numAddAxisAfterEllipsis++,1<<e&l&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(s),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(a),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(p,f);let m=!0,g=!0,y=!0;const b=[],w=[];for(let t=0;t<e.length;++t){if(0===f.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(f.shrinkAxisMask&1<<t),r=e[t];if(-1===r){b.push(n?1:-1);continue}const s=[f.beginMask&1<<t,f.endMask&1<<t],a=[f.strides[t]>0?0:-1,f.strides[t]>0?r:r-1];if(n&&f.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&1===f.strides[t];const i=!!(f.beginMask&1<<t&&f.endMask&1<<t);if(f.beginValid&&f.endValid){if(n){const e=f.begin[t]<0?r+f.begin[t]:f.begin[t];if(f.begin[t]=e,f.end[t]=f.begin[t]+1,e<0||e>=r)throw Error(`slice index ${f.begin[t]} of dimension ${t} out of bounds.`)}else f.begin[t]=A(f.begin[t],0,f.strides[t],r,s,a),f.end[t]=A(f.end[t],1,f.strides[t],r,s,a);const e=1===f.strides[t]&&0===f.begin[t]&&f.end[t]===r;m=m&&e,g=g&&(0===t&&1===f.strides[t]||e)}else m=m&&1===f.strides[t]&&i,g=g&&(0===t&&1===f.strides[t]||i);let o,l=!1;if(f.beginValid&&f.endValid?(o=f.end[t]-f.begin[t],l=!0):n?(o=1,l=!0):i&&r>=0&&(o=f.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=f.strides[t]<0?0:Math.trunc(o/f.strides[t])+(o%f.strides[t]!=0?1:0),b.push(e)}else b.push(-1)}for(let e=0;e<f.finalShapeGatherIndices.length;++e){const t=f.finalShapeGatherIndices[e];t>=0?w.push(b[t]):t===s&&w.push(1)}return{finalShapeSparse:w.filter(((e,t)=>f.finalShapeGatherIndices[t]!==s)),finalShape:w,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:f.begin,end:f.end,strides:f.strides}}function A(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}},66030:(e,t,n)=>{n.d(t,{l:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({softplus_:function(e){const t={x:(0,a.YT)(e,"x","softplus")};return r.T2.runKernel(s.Fin,t)}})},10776:(e,t,n)=>{n.d(t,{e:()=>o});var r=n(67897),s=n(15441),a=n(28189),i=n(45119);const o=(0,n(70929).op)({spaceToBatchND_:function(e,t,n){const o=(0,a.YT)(e,"x","spaceToBatchND");i.vA(o.rank>=1+t.length,(()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`)),i.vA(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),i.vA(o.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const l={x:o},u={blockShape:t,paddings:n};return r.T2.runKernel(s.A8B,l,u)}})},77618:(e,t,n)=>{function r(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function s(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function a(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}n.d(t,{P_:()=>r,U8:()=>s,zP:()=>a})},83255:(e,t,n)=>{n.d(t,{M5:()=>a,Ni:()=>o,Pz:()=>i,pC:()=>l,yM:()=>s});var r=n(45119);function s(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function a(e,t){return`size ${e} must be non-negative, not ${t}`}function i(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function o(e,t){return`Input to reshape is a SparseTensor with ${(0,r.Ze)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,r.Ze)(t)}. inputShape=${e} outputShape= ${t}`}function l(e,t){return`Input to reshape is a tensor with ${(0,r.Ze)(e)} dense values, but the requested shape has ${(0,r.Ze)(t)}. inputShape=${e} outputShape=${t}`}},55880:(e,t,n)=>{function r(){return"segment ids must be >= 0"}function s(){return"segment ids are not increasing"}function a(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function i(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}n.d(t,{AP:()=>a,dS:()=>i,tb:()=>s,u1:()=>r})},66512:(e,t,n)=>{n.d(t,{l:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({split_:function(e,t,n=0){const i={x:(0,a.YT)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return r.T2.runKernel(s.Blb,i,o)}})},57303:(e,t,n)=>{n.d(t,{z:()=>s});var r=n(45119);function s(e,t,n=0){let s=[];if("number"==typeof t)(0,r.vA)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),s=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,r.vA)(a<=1,(()=>"There should be only one negative value in split array."));const i=t.indexOf(-1);if(-1!==i){const r=t.reduce(((e,t)=>t>0?e+t:e));t[i]=e.shape[n]-r}(0,r.vA)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),s=t}return s}},79348:(e,t,n)=>{n.d(t,{R:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({sqrt_:function(e){const t={x:(0,a.YT)(e,"x","sqrt","float32")};return r.T2.runKernel(s.dFH,t)}})},45793:(e,t,n)=>{n.d(t,{E:()=>a});var r=n(67897),s=n(28189);const a=(0,n(70929).op)({square_:function(e){const t=(0,s.YT)(e,"x","square");return r.T2.runKernel("Square",{x:t},{})}})},53427:(e,t,n)=>{n.d(t,{P:()=>l});var r=n(67897),s=n(15441),a=n(30565),i=n(28189),o=n(62198);const l=(0,n(70929).op)({squaredDifference_:function(e,t){let n=(0,i.YT)(e,"a","squaredDifference"),l=(0,i.YT)(t,"b","squaredDifference");[n,l]=(0,a.h0)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.Ddj,u,{})}})},5932:(e,t,n)=>{n.d(t,{r:()=>o});var r=n(28189),s=n(45119),a=n(70929),i=n(62302);const o=(0,a.op)({squeeze_:function(e,t){const n=(0,r.YT)(e,"x","squeeze","string_or_numeric");return(0,i.t)(n,(0,s.gx)(n.shape,t).newShape)}})},54268:(e,t,n)=>{n.d(t,{t:()=>o});var r=n(67897),s=n(15441),a=n(28189),i=n(45119);const o=(0,n(70929).op)({stack_:function(e,t=0){const n=(0,a.j1)(e,"tensors","stack","string_or_numeric");i.vA(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&i.vA(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const o=n,l={axis:t};return r.T2.runKernel(s.mM$,o,l)}})},10700:(e,t,n)=>{n.d(t,{P:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({step_:function(e,t=0){const n={x:(0,a.YT)(e,"x","step")},i={alpha:t};return r.T2.runKernel(s.pnw,n,i)}})},77126:(e,t,n)=>{n.d(t,{j:()=>o});var r=n(67897),s=n(15441),a=n(30565),i=n(28189);const o=(0,n(70929).op)({sub_:function(e,t){let n=(0,i.YT)(e,"a","sub"),o=(0,i.YT)(t,"b","sub");[n,o]=(0,a.h0)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.PbM,l)}})},83791:(e,t,n)=>{n.d(t,{c:()=>o});var r=n(67897),s=n(15441),a=n(28189),i=n(29809);const o=(0,n(70929).op)({sum_:function(e,t=null,n=!1){let o=(0,a.YT)(e,"x","sum");"bool"===o.dtype&&(o=(0,i.w)(o,"int32"));const l={x:o},u={axis:t,keepDims:n};return r.T2.runKernel(s.WuN,l,u)}})},57311:(e,t,n)=>{n.d(t,{y:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({tanh_:function(e){const t={x:(0,a.YT)(e,"x","tanh","float32")};return r.T2.runKernel(s.iuW,t)}})},74027:(e,t,n)=>{n.d(t,{O:()=>a});var r=n(28189),s=n(19171);function a(e,t,n){const a=(0,r.MZ)(e,n);return(0,s.Q)(e,t,a,n)}},62018:(e,t,n)=>{n.d(t,{t:()=>i});var r=n(28189),s=n(45119),a=n(19171);function i(e,t){(0,s.HO)(e);const n=(0,r.MZ)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,a.Q)(e,null,n,t)}},18941:(e,t,n)=>{n.d(t,{K:()=>i});var r=n(28189),s=n(45119),a=n(19171);function i(e,t,n){if((0,s.HO)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const i=(0,r.MZ)(e,n);if(2!==i.length&&1!==i.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,a.Q)(e,t,i,n)}},42768:(e,t,n)=>{n.d(t,{$:()=>i});var r=n(28189),s=n(45119),a=n(19171);function i(e,t,n){if((0,s.HO)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=(0,r.MZ)(e,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,a.Q)(e,t,i,n)}},19171:(e,t,n)=>{n.d(t,{Q:()=>i});var r=n(67897),s=n(45119),a=n(89783);function i(e,t,n,i){if(null==i)i=(0,s.X$)(e);else if("complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof e&&("texture"in e||"buffer"in e&&!(e.buffer instanceof ArrayBuffer))){if("float32"!==i&&"int32"!==i)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${i}.`);return r.T2.backend.createTensorFromGPUData(e,t||n,i)}if(!(0,a.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,s.SA)(t);const e=(0,s.Ze)(t),r=(0,s.Ze)(n);(0,s.vA)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],a=e!==n.length-1||r!==(0,s.Ze)(t.slice(e));(0,s.vA)(n[e]===t[e]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,a.isTypedArray)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==i?(0,a.toTypedArray)(e,i):(0,a.flatten)(e,[],!0),r.T2.makeTensor(e,t,i)}},64826:(e,t,n)=>{n.d(t,{V:()=>o});var r=n(67897),s=n(15441),a=n(28189),i=n(45119);const o=(0,n(70929).op)({tile_:function(e,t){const n=(0,a.YT)(e,"x","tile","string_or_numeric");i.vA(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const o={x:n},l={reps:t};return r.T2.runKernel(s.FAs,o,l)}})},7703:(e,t,n)=>{n.d(t,{m:()=>p});var r=n(67897),s=n(35287),a=n(15441),i=n(28189),o=n(45119),l=n(37148),u=n(35040),c=n(96522),h=n(70929),d=n(1902);const p=(0,h.op)({transpose_:function(e,t,n){const h=(0,i.YT)(e,"x","transpose");if(null==t&&(t=h.shape.map(((e,t)=>t)).reverse()),o.vA(h.rank===t.length,(()=>`Error in transpose: rank of input ${h.rank} must match length of perm ${t}.`)),t.forEach((e=>{o.vA(e>=0&&e<h.rank,(()=>"All entries in 'perm' must be between 0 and "+(h.rank-1)+` but got ${t}`))})),h.rank<=1)return h.clone();const p={x:h},f={perm:t};return"complex64"===h.dtype?(0,s.DZ)((()=>{let e=(0,d.x)(h),t=(0,u.n)(h);return e=r.T2.runKernel(a.wx0,{x:e},f),t=r.T2.runKernel(a.wx0,{x:t},f),n&&(t=(0,c.H)(t)),(0,l.f)(e,t)})):r.T2.runKernel(a.wx0,p,f)}})},97706:(e,t,n)=>{n.d(t,{z:()=>o});var r=n(67897),s=n(15441),a=n(28189),i=n(45119);const o=(0,n(70929).op)({unsortedSegmentSum_:function(e,t,n){const o=(0,a.YT)(e,"x","unsortedSegmentSum"),l=(0,a.YT)(t,"segmentIds","unsortedSegmentSum","int32");(0,i.vA)((0,i.E6)(n),(()=>"numSegments must be of dtype int"));const u={x:o,segmentIds:l},c={numSegments:n};return r.T2.runKernel(s.pPe,u,c)}})},67261:(e,t,n)=>{n.d(t,{K:()=>o});var r=n(67897),s=n(15441),a=n(28189),i=n(45119);const o=(0,n(70929).op)({unstack_:function(e,t=0){const n=(0,a.YT)(e,"x","unstack","string_or_numeric");i.vA(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const o={value:n},l={axis:t};return r.T2.runKernel(s.dXR,o,l)}})},12151:(e,t,n)=>{n.d(t,{_:()=>l});var r=n(67897),s=n(15441),a=n(28189),i=n(63567),o=n(62198);const l=(0,n(70929).op)({where_:function(e,t,n){const l=(0,a.YT)(t,"a","where"),u=(0,a.YT)(n,"b","where"),c=(0,a.YT)(e,"condition","where","bool"),h=(0,o.assertAndGetBroadcastShape)((0,o.assertAndGetBroadcastShape)(c.shape,l.shape),u.shape),d={condition:(0,i.h)(c,h),t:(0,i.h)(l,h),e:(0,i.h)(u,h)};return r.T2.runKernel(s.l6P,d)}})},44271:(e,t,n)=>{n.d(t,{Y:()=>a});var r=n(54411),s=n(28189);const a=async function(e){const t=(0,s.YT)(e,"condition","whereAsync","bool"),n=await t.data(),a=(0,r.Y)(t.shape,n);return e!==t&&t.dispose(),a}},42855:(e,t,n)=>{n.d(t,{U:()=>i});var r=n(67897),s=n(45119),a=n(37148);function i(e,t="float32"){if((0,s.SA)(e),"complex64"===t){const t=i(e,"float32"),n=i(e,"float32");return(0,a.f)(t,n)}const n=(0,s.Ty)((0,s.Ze)(e),t);return r.T2.makeTensor(n,e,t)}},55537:(e,t,n)=>{n.d(t,{P:()=>i});var r=n(67897),s=n(15441),a=n(28189);const i=(0,n(70929).op)({zerosLike_:function(e){const t={x:(0,a.YT)(e,"x","zerosLike")};return r.T2.runKernel(s.xJ3,t)}})},99696:(e,t,n)=>{n.d(t,{K:()=>d});var r=n(67897),s=n(35287),a=n(37523),i=n(89359),o=n(9258),l=n(79348),u=n(45793),c=n(55537),h=n(64403);class d extends h.E{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=r.T2.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const h=r.T2.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,s.DZ)((()=>(0,c.P)(h).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,s.DZ)((()=>(0,c.P)(h).variable(!1)))});const d=Array.isArray(e)?e[n].tensor:e[t];if(null==d)return;const p=this.accumulatedGrads[n].variable,f=this.accumulatedUpdates[n].variable;(0,s.DZ)((()=>{const e=(0,a.W)((0,o.l)(p,this.rho),(0,o.l)((0,u.E)(d),1-this.rho)),t=(0,o.l)((0,i.y)((0,l.R)((0,a.W)(f,this.epsilon)),(0,l.R)((0,a.W)(p,this.epsilon))),d),n=(0,a.W)((0,o.l)(f,this.rho),(0,o.l)((0,u.E)(t),1-this.rho));p.assign(e),f.assign(n);const r=(0,a.W)((0,o.l)(t,-this.learningRate),h);h.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,s.AS)(this.accumulatedGrads.map((e=>e.variable))),(0,s.AS)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}},85316:(e,t,n)=>{n.d(t,{a:()=>d});var r=n(67897),s=n(35287),a=n(37523),i=n(89359),o=n(96111),l=n(9258),u=n(79348),c=n(45793),h=n(64403);class d extends h.E{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const h=r.T2.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,s.DZ)((()=>(0,o.G)(h.shape,this.initialAccumulatorValue).variable(e)))}}const d=Array.isArray(e)?e[n].tensor:e[t];if(null==d)return;const p=this.accumulatedGrads[n].variable;(0,s.DZ)((()=>{const e=(0,a.W)(p,(0,c.E)(d));p.assign(e);const t=(0,a.W)((0,l.l)((0,i.y)(d,(0,u.R)((0,a.W)(e,r.T2.backend.epsilon()))),-this.learningRate),h);h.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,s.AS)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}},81409:(e,t,n)=>{n.d(t,{F:()=>m});var r=n(67897),s=n(35287),a=n(37523),i=n(89359),o=n(9258),l=n(98990),u=n(45702),c=n(79348),h=n(45793),d=n(77126),p=n(55537),f=n(64403);class m extends f.E{constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,s.DZ)((()=>{this.accBeta1=(0,u.d)(t).variable(),this.accBeta2=(0,u.d)(n).variable()})),null==a&&(this.epsilon=r.T2.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,s.DZ)((()=>{const n=(0,d.j)(1,this.accBeta1),l=(0,d.j)(1,this.accBeta2);t.forEach(((t,u)=>{const d=r.T2.registeredVariables[t];null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${t}/m`,variable:(0,s.DZ)((()=>(0,p.P)(d).variable(!1)))}),null==this.accumulatedSecondMoment[u]&&(this.accumulatedSecondMoment[u]={originalName:`${t}/v`,variable:(0,s.DZ)((()=>(0,p.P)(d).variable(!1)))});const f=Array.isArray(e)?e[u].tensor:e[t];if(null==f)return;const m=this.accumulatedFirstMoment[u].variable,g=this.accumulatedSecondMoment[u].variable,y=(0,a.W)((0,o.l)(m,this.beta1),(0,o.l)(f,1-this.beta1)),b=(0,a.W)((0,o.l)(g,this.beta2),(0,o.l)((0,h.E)(f),1-this.beta2)),w=(0,i.y)(y,n),v=(0,i.y)(b,l);m.assign(y),g.assign(b);const T=(0,a.W)((0,o.l)((0,i.y)(w,(0,a.W)((0,c.R)(v),this.epsilon)),-this.learningRate),d);d.assign(T)})),this.accBeta1.assign((0,o.l)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,o.l)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,s.AS)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&(0,s.AS)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),(0,s.DZ)((()=>{this.accBeta1.assign((0,l.n)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,l.n)(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}},98544:(e,t,n)=>{n.d(t,{o:()=>f});var r=n(67897),s=n(35287),a=n(4888),i=n(37523),o=n(89359),l=n(30178),u=n(9258),c=n(45702),h=n(77126),d=n(55537),p=n(64403);class f extends p.E{constructor(e,t,n,a=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,s.DZ)((()=>{this.iteration=(0,c.d)(0).variable(),this.accBeta1=(0,c.d)(t).variable()})),null==a&&(this.epsilon=r.T2.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,s.DZ)((()=>{const n=(0,h.j)(1,this.accBeta1),s=(0,o.y)(-this.learningRate,(0,i.W)((0,u.l)(this.iteration,this.decay),1));t.forEach(((t,c)=>{const h=r.T2.registeredVariables[t];null==this.accumulatedFirstMoment[c]&&(this.accumulatedFirstMoment[c]={originalName:`${t}/m`,variable:(0,d.P)(h).variable(!1)}),null==this.accumulatedWeightedInfNorm[c]&&(this.accumulatedWeightedInfNorm[c]={originalName:`${t}/v`,variable:(0,d.P)(h).variable(!1)});const p=Array.isArray(e)?e[c].tensor:e[t];if(null==p)return;const f=this.accumulatedFirstMoment[c].variable,m=this.accumulatedWeightedInfNorm[c].variable,g=(0,i.W)((0,u.l)(f,this.beta1),(0,u.l)(p,1-this.beta1)),y=(0,u.l)(m,this.beta2),b=(0,a.t)(p),w=(0,l.P)(y,b);f.assign(g),m.assign(w);const v=(0,i.W)((0,u.l)((0,o.y)(s,n),(0,o.y)(g,(0,i.W)(w,this.epsilon))),h);h.assign(v)})),this.iteration.assign((0,i.W)(this.iteration,1)),this.accBeta1.assign((0,u.l)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,s.AS)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&(0,s.AS)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}},5340:(e,t,n)=>{n.d(t,{Q:()=>c});var r=n(67897),s=n(35287),a=n(37523),i=n(9258),o=n(45702),l=n(55537),u=n(37930);class c extends u.S{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,o.d)(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=r.T2.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,s.DZ)((()=>(0,l.P)(o).variable(e)))}}const u=this.accumulations[n].variable,c=Array.isArray(e)?e[n].tensor:e[t];null!=c&&(0,s.DZ)((()=>{let e;const t=(0,a.W)((0,i.l)(this.m,u),c);e=this.useNesterov?(0,a.W)((0,i.l)(this.c,(0,a.W)(c,(0,i.l)(t,this.m))),o):(0,a.W)((0,i.l)(this.c,t),o),u.assign(t),o.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,s.AS)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}},64403:(e,t,n)=>{n.d(t,{E:()=>o});var r=n(35287),s=n(31830),a=n(45702),i=n(79559);class o extends i.Serializable{minimize(e,t=!1,n){const{value:s,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return(0,r.AS)(a),t?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,s.y7)(e,t)}dispose(){null!=this.iterations_&&(0,r.AS)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,a.d)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(o,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients})},63822:(e,t,n)=>{n.d(t,{i:()=>d});var r=n(99696),s=n(85316),a=n(81409),i=n(98544),o=n(5340),l=n(25727),u=n(37930),c=n(79559);const h=[r.K,s.a,a.F,i.o,o.Q,l.P,u.S];function d(){for(const e of h)(0,c.registerClass)(e)}},25727:(e,t,n)=>{n.d(t,{P:()=>p});var r=n(67897),s=n(35287),a=n(37523),i=n(89359),o=n(9258),l=n(79348),u=n(45793),c=n(77126),h=n(55537),d=n(64403);class p extends d.E{constructor(e,t=.9,n=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==s&&(this.epsilon=r.T2.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const d=r.T2.registeredVariables[t],p=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,s.DZ)((()=>(0,h.P)(d).variable(p)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,s.DZ)((()=>(0,h.P)(d).variable(p)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,s.DZ)((()=>(0,h.P)(d).variable(p)))});const f=Array.isArray(e)?e[n].tensor:e[t];if(null==f)return;const m=this.accumulatedMeanSquares[n].variable,g=this.accumulatedMoments[n].variable;(0,s.DZ)((()=>{const e=(0,a.W)((0,o.l)(m,this.decay),(0,o.l)((0,u.E)(f),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=(0,a.W)((0,o.l)(t,this.decay),(0,o.l)(f,1-this.decay)),s=(0,i.y)((0,o.l)(f,this.learningRate),(0,l.R)((0,c.j)(e,(0,a.W)((0,u.E)(r),this.epsilon)))),h=(0,a.W)((0,o.l)(g,this.momentum),s);m.assign(e),t.assign(r),g.assign(h);const p=(0,c.j)(d,h);d.assign(p)}else{const e=(0,a.W)((0,o.l)(m,this.decay),(0,o.l)((0,u.E)(f),1-this.decay)),t=(0,a.W)((0,o.l)(g,this.momentum),(0,i.y)((0,o.l)(f,this.learningRate),(0,l.R)((0,a.W)(e,this.epsilon))));m.assign(e),g.assign(t);const n=(0,c.j)(d,t);d.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,s.AS)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,s.AS)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&(0,s.AS)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}},37930:(e,t,n)=>{n.d(t,{S:()=>u});var r=n(67897),s=n(35287),a=n(37523),i=n(9258),o=n(45702),l=n(64403);class u extends l.E{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const l=r.T2.registeredVariables[t];(0,s.DZ)((()=>{const e=(0,a.W)((0,i.l)(this.c,o),l);l.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,s.aC)((0,o.d)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}},15618:(e,t,n)=>{n(66652);var r=n(46574),s=n(30522),a=n(76745),i=n(66235);class o{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&(0,r._K)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}}if((0,r._K)().get("IS_BROWSER")){(0,r._K)().setPlatform("browser",new o);try{i.dy.registerManager(a.ZT.URL_SCHEME,new a.Cd)}catch(e){}try{i.dy.registerManager(s.mn.URL_SCHEME,new s.lQ)}catch(e){}}},83672:(e,t,n)=>{var r=n(46574);let s;(0,r._K)().get("IS_NODE")&&!(0,r._K)().get("IS_BROWSER")&&(0,r._K)().setPlatform("node",new class{constructor(){this.util=n(18590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,r._K)().global.fetch?(0,r._K)().global.fetch(e,t):(null==s&&(s=n(85817)),s(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}})},41466:(e,t,n)=>{n.d(t,{UD:()=>i});var r=n(46574),s=n(89783),a=n(45119);class i{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new l)}profileKernel(e,t,n){let a;const i=()=>{a=n()};let l;const u=s.now();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(i);else{i();for(const e of a)e.dataSync();l=Promise.resolve({kernelMs:s.now()-u})}if((0,r._K)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<a.length;t++){const n=a[t];n.data().then((t=>{o(t,n.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:l.then((e=>e.kernelMs)),extraInfo:l.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function o(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class l{logKernelProfile(e,t,n,r,s,i){const o="number"==typeof r?a.av(`${r}ms`,9):r.error,l=a.av(e,25),u=t.rank,c=t.size,h=a.av(t.shape.toString(),14);let d="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;d+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${l}\t%c${o}\t%c${u}D ${h}\t%c${c}\t%c${d}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}},71888:(e,t,n)=>{var r=n(83320),s=n(72750),a=n(76070),i=n(92249),o=n(35373),l=n(50842),u=n(96472),c=n(39569),h=n(23231),d=n(73276),p=n(33962),f=n(59722),m=n(45079),g=n(20570),y=n(78172),b=n(15389),w=n(76682),v=n(33665),T=n(20099),A=n(83952),S=n(65872),E=n(26012),$=n(48144),k=n(17258),x=n(51099),_=n(60685),M=n(34451),I=n(78158),N=n(62366),R=n(68084),D=n(96916),Y=n(17641),P=n(88861),F=n(16633),W=n(86431),G=n(57826),O=n(25131),K=n(3173),V=n(333),z=n(60918),q=n(40726),C=n(73005),U=n(12741),B=n(48971),Z=n(63884),L=n(39057),j=n(72982),H=n(59040),Q=n(29372),X=n(842),J=n(89946),ee=n(85573),te=n(43668),ne=n(95931),re=n(91304),se=n(9544),ae=n(78260),ie=n(18808),oe=n(23900),le=n(47442),ue=n(4613),ce=n(82934),he=n(41295),de=n(25363),pe=n(21466),fe=n(49614),me=n(37395),ge=n(6621),ye=n(81223),be=n(62152),we=n(55786),ve=n(38486),Te=n(30988),Ae=n(91652),Se=n(74562),Ee=n(75308),$e=n(69984),ke=n(43524),xe=n(60309),_e=n(97540),Me=n(63275),Ie=n(86942),Ne=n(6006),Re=n(58406),De=n(6886),Ye=n(70244),Pe=n(49745),Fe=n(35922),We=n(12486),Ge=n(95809),Oe=n(52878),Ke=n(17278),Ve=n(13390),ze=n(6981),qe=n(4861),Ce=n(99587),Ue=n(26680),Be=n(43561),Ze=n(55698),Le=n(47774),je=n(37492),He=n(37074);const Qe=[r.B,s.l,a.h,i.Y,o.y,l.Z,u.l,c._,h.O,d.B,p.z,f.n,m.m,g.$,y.v,b.I,w.X,v.Q,T.C,A.Z,S.N,E.N,k.R,$.J,x.Y,_.g,M.M,I.Z,N.z,R.v,ge.g,D.x,Y.S,P.k,F.y,W.a,O.S,G.n,K.E,V.E,z.D,q.L,C.c,U.c,B.C,Z.f,L.G,j.V,H.z,Q.J,X.n,X.n,J.p,ee.S,te.P,ne.k,re.Z,se.$,ae.P,ie.$,oe.r,le.h,ue.U,ce.P,he.I,de.M,de.M,pe.d,fe.t,me.a,ye.j,be.p,we.T,ve.x,Te.j,Ae.n,Se.D,Ee.v,$e.$,ke.D,xe.O,_e.H,Me.q,Ie.V,Ne.l,Re.d,De.X,Ye.F,Pe.Y,Pe.Y,Fe.n,Fe.n,We.V,Oe.b,Ge.M,Ke.f,Ve.p,ze.m,qe.k,Ce.w,Ue.X,Be.m,Ze.t,Le.h,je.Z];for(const e of Qe)(0,He.kr)(e)},79559:(e,t,n)=>{n.r(t),n.d(t,{Serializable:()=>s,SerializationMap:()=>a,registerClass:()=>i});var r=n(45119);class s{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class a{constructor(){this.classNameMap={}}static getMap(){return null==a.instance&&(a.instance=new a),a.instance}static register(e){a.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function i(e){(0,r.vA)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),(0,r.vA)("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),(0,r.vA)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),a.register(e)}},37427:(e,t,n)=>{n.d(t,{a:()=>a,p:()=>s});var r=n(45119);function s(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}function a(e,t,n,s){for(let a=t.length-1;a>=0;a--){const i=t[a],o=[];if(i.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const t in i.inputs){if(!(t in l))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(l)}.`);const a=n((()=>l[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const o=i.inputs[t];if(!r.r1(a.shape,o.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{const t=e[o.id];e[o.id]=s(t,a),t.dispose()}}}}},50259:(e,t,n)=>{n.d(t,{qY:()=>T,yl:()=>f,rT:()=>A,B4:()=>v,Q5:()=>w,qP:()=>b});var r=n(41743),s=n(45119);const a=20,i=3,o=7;function l(e,t,n,r){const a=(0,s.Ur)(t),i=function(e,t,n,r){const a=(0,s.Ze)(t),i=r[r.length-1],o=new Array(i).fill(0),l=t.length,c="complex64"===n?d(e):e;if(l>1)for(let e=0;e<a/i;e++){const t=e*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],u(c[t+e],0,n).length)}return o}(e,t,n,a),o=t.length,l=h(e,t,n,a,i),c=["Tensor"];return r&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map((e=>"    "+e)).join("\n")),c.join("\n")}function u(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(o))} + ${parseFloat(e[1].toFixed(o))}j`:(0,s.Kg)(e)?`'${e}'`:"bool"===n?c(e):parseFloat(e.toFixed(o)).toString(),(0,s.av)(r,t)}function c(e){return 0===e?"false":"true"}function h(e,t,n,r,s,o=!0){const l="complex64"===n?2:1,p=t[0],f=t.length;if(0===f)return"complex64"===n?[u(d(e)[0],0,n)]:"bool"===n?[c(e[0])]:[e[0].toString()];if(1===f){if(p>a){const t=i*l;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((p-i)*l,p*l));return"complex64"===n&&(r=d(r),a=d(a)),["["+r.map(((e,t)=>u(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>u(e,s[p-i+t],n))).join(", ")+"]"]}return["["+("complex64"===n?d(e):Array.from(e)).map(((e,t)=>u(e,s[t],n))).join(", ")+"]"]}const m=t.slice(1),g=r.slice(1),y=r[0]*l,b=[];if(p>a){for(let t=0;t<i;t++){const r=t*y,a=r+y;b.push(...h(e.slice(r,a),m,n,g,s,!1))}b.push("...");for(let t=p-i;t<p;t++){const r=t*y,a=r+y;b.push(...h(e.slice(r,a),m,n,g,s,t===p-1))}}else for(let t=0;t<p;t++){const r=t*y,a=r+y;b.push(...h(e.slice(r,a),m,n,g,s,t===p-1))}const w=2===f?",":"";b[0]="["+(p>0?b[0]+w:"");for(let e=1;e<b.length-1;e++)b[e]=" "+b[e]+w;let v=",\n";for(let e=2;e<f;e++)v+="\n";return b[b.length-1]=" "+b[b.length-1]+"]"+(o?"":v),b}function d(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var p=n(89783);class f{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=s.Ze(e),null!=n){const e=n.length;s.vA(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||s.Ab(t,this.size),this.strides=(0,s.Ur)(e)}set(e,...t){0===t.length&&(t=[0]),s.vA(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return m().makeTensor(this.values,this.shape,this.dtype)}}let m=null,g=null,y=null;function b(e){m=e}function w(e){g=e}function v(e){y=e}class T{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=s.Ze(e),this.strides=(0,s.Ur)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return g.buffer(this.shape,this.dtype,e)}bufferSync(){return g.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,s.yw)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,s.yw)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=m().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>p.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),m().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=m().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>p.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await m().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(m().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return g.print(this,e)}clone(){return this.throwIfDisposed(),g.clone(this)}toString(e=!1){return l(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),g.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),m().makeVariable(this,e,t,n)}}Object.defineProperty(T,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),(0,r.m)("Tensor",(()=>T));class A extends T{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!s.r1(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);m().disposeTensor(this),this.dataId=e.dataId,m().incRef(this,null)}dispose(){m().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(A,Symbol.hasInstance,{value:e=>e instanceof T&&null!=e.assign&&e.assign instanceof Function})},30565:(e,t,n)=>{n.d(t,{NB:()=>l,h0:()=>i,rt:()=>o});var r=n(50259),s=n(52046),a=n(45119);function i(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,s.Tu)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function o(e,t){(0,a.vA)(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function l(e){const t=[];return u(e,t,new Set),t}function u(e,t,n){if(null==e)return;if(e instanceof r.qY)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const a=e;for(const e in a){const r=a[e];n.has(r)||(n.add(r),u(r,t,n))}}},28189:(e,t,n)=>{n.d(t,{MZ:()=>l,YT:()=>h,j1:()=>d});var r=n(67897),s=n(46574),a=n(50259),i=n(89783),o=n(45119);function l(e,t){let n=e;if((0,i.isTypedArray)(e))return"string"===t?[]:[e.length];if("object"==typeof e){if("texture"in e){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if("buffer"in e&&!(e.buffer instanceof ArrayBuffer))return[e.buffer.size/(null==t?4:(0,o.jv)(t))]}if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||(0,i.isTypedArray)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,s._K)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&u(e,r,[]),r}function u(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,i.isTypedArray)(e))return void(0,o.vA)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,o.vA)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,o.vA)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)u(e[t],r,n.concat(t))}function c(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function h(e,t,n,s="numeric"){if(e instanceof a.qY)return c(s,e.dtype,t,n),e;let u=(0,o.X$)(e);if("string"!==u&&["bool","int32","float32"].indexOf(s)>=0&&(u=s),c(s,u,t,n),null==e||!(0,i.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const h=l(e,u);(0,i.isTypedArray)(e)||Array.isArray(e)||(e=[e]);const d="string"!==u?(0,i.toTypedArray)(e,u):(0,i.flatten)(e,[],!0);return r.T2.makeTensor(d,h,u)}function d(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>h(e,`${t}[${s}]`,n,r)))}},19115:(e,t,n)=>{n.d(t,{B:()=>c});var r=n(99696),s=n(85316),a=n(81409),i=n(98544),o=n(5340),l=n(25727),u=n(37930);const c=class{static sgd(e){return new u.S(e)}static momentum(e,t,n=!1){return new o.Q(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new l.P(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new a.F(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new r.K(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new i.o(e,t,n,r,s)}static adagrad(e,t=.1){return new s.a(e,t)}}},52046:(e,t,n)=>{var r,s,a,i,o;n.d(t,{Tu:()=>u,ch:()=>c}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(a||(a={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(i||(i={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(o||(o={}));const l={float32:i,int32:s,bool:a,complex64:o};function u(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return l[e][t]}function c(e){return u(e,"int32")}},89783:(e,t,n)=>{n.r(t),n.d(t,{arraysEqual:()=>s.r1,assert:()=>s.vA,assertNonNegativeIntegerDimensions:()=>s.SA,assertNonNull:()=>s.HO,assertShapesMatch:()=>s.O3,bytesFromStringArray:()=>s.SL,bytesPerElement:()=>s.jv,checkConversionForErrors:()=>s.nd,clamp:()=>s.qE,computeStrides:()=>s.Ur,convertBackendValuesAndArrayBuffer:()=>s.o2,createScalarValue:()=>i,createShuffledIndices:()=>s.P8,decodeString:()=>h,distSquared:()=>s.oO,encodeString:()=>c,fetch:()=>u,fingerPrint64:()=>a.D,flatten:()=>p,getArrayFromDType:()=>s.Ab,getTypedArrayFromDType:()=>s.ce,hasEncodingLoss:()=>s.BE,hexToLong:()=>a.f,indexToLoc:()=>s._k,inferDtype:()=>s.X$,inferFromImplicitShape:()=>s.XT,isBoolean:()=>s.Lm,isFunction:()=>s.Tn,isInt:()=>s.E6,isNumber:()=>s.Et,isPromise:()=>s.yL,isScalarShape:()=>s.Sf,isString:()=>s.Kg,isTypedArray:()=>d,isValidDtype:()=>s.xn,locToIndex:()=>s.sX,makeOnesTypedArray:()=>s.FZ,makeZerosNestedTypedArray:()=>s.c7,makeZerosTypedArray:()=>s.Ty,nearestDivisor:()=>s.lK,nearestLargerEven:()=>s.eV,now:()=>l,parseAxisParam:()=>s.Y6,randUniform:()=>s.so,repeatedTry:()=>s._q,rightPad:()=>s.av,shuffle:()=>s.k4,shuffleCombo:()=>s.a0,sizeFromShape:()=>s.Ze,sizeToSquarishShape:()=>s.gS,squeezeShape:()=>s.gx,sum:()=>s.cz,swap:()=>s.wg,tanh:()=>s.ym,toNestedArray:()=>s.yw,toTypedArray:()=>o});var r=n(46574),s=n(45119),a=n(26286);function i(e,t){return"string"===t?c(e):o([e],t)}function o(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=p(e)),(0,r._K)().getBool("DEBUG")&&s.nd(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function l(){return(0,r._K)().platform.now()}function u(e,t){return(0,r._K)().platform.fetch(e,t)}function c(e,t="utf-8"){return t=t||"utf-8",(0,r._K)().platform.encode(e,t)}function h(e,t="utf-8"){return t=t||"utf-8",(0,r._K)().platform.decode(e,t)}function d(e){return(0,r._K)().platform.isTypedArray(e)}function p(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||s.yL(e)||null==e||d(e)&&n)t.push(e);else if(Array.isArray(e)||d(e))for(let r=0;r<e.length;++r)p(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)p(e[s],t,n)}return t}},45119:(e,t,n)=>{function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,o(e,t,n)}function s(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,o(e,n,r),o(t,n,r)}function a(e,t,n){return Math.max(e,Math.min(t,n))}function i(e){return e%2==0?e:e+1}function o(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function l(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function u(e,t){const n=Math.random();return t*n+(1-n)*e}function c(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function h(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function d(e,t,n=""){h(g(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function p(e){h(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function f(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function m(e){return 0===e.length}function g(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function y(e){return e%1==0}function b(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function w(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function v(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function T(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function A(e,t=(e=>0),n,r){return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function S(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function E(e,t){const n=t.length;return h((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),h(e.every((e=>y(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function $(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:E(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function k(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function x(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function _(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function M(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function I(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function N(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function R(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function D(e){return"string"==typeof e||e instanceof String}function Y(e){return"boolean"==typeof e}function P(e){return"number"==typeof e}function F(e){return Array.isArray(e)?F(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":P(e)?"float32":D(e)?"string":Y(e)?"bool":"float32"}function W(e){return!!(e&&e.constructor&&e.call&&e.apply)}function G(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function O(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function K(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=K(e+t*o,i,n,r)}return s}function V(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return K(0,e,t,n)}function z(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function q(e,t){const n=C(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function C(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function U(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return V(e,new Float32Array(n));if("int32"===t)return V(e,new Int32Array(n));if("bool"===t)return V(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function B(e){e.forEach((t=>{h(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Z(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function L(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function j(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{Ab:()=>x,BE:()=>I,E6:()=>y,Et:()=>P,FZ:()=>q,HO:()=>p,Kg:()=>D,Lm:()=>Y,O3:()=>d,P8:()=>v,SA:()=>B,SL:()=>R,Sf:()=>m,Tn:()=>W,Ty:()=>C,Ur:()=>O,X$:()=>F,XT:()=>S,Y6:()=>E,Ze:()=>f,_k:()=>L,_q:()=>A,a0:()=>s,av:()=>T,c7:()=>U,ce:()=>k,cz:()=>l,eV:()=>i,gS:()=>w,gx:()=>$,jv:()=>N,k4:()=>r,lK:()=>G,nd:()=>_,o2:()=>z,oO:()=>c,qE:()=>a,r1:()=>g,sX:()=>Z,so:()=>u,vA:()=>h,wg:()=>o,xn:()=>M,yL:()=>j,ym:()=>b,yw:()=>V})}}]);