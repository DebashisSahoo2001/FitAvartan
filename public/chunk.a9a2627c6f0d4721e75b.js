/*! For license information please see chunk.a9a2627c6f0d4721e75b.js.LICENSE.txt */
"use strict";(self.webpackChunkai_workout_assistant=self.webpackChunkai_workout_assistant||[]).push([[439],{73388:(e,n,t)=>{t.d(n,{f:()=>d});var a=t(36115),s=t(60287),r=t(62780),o=t(43008);function i(e,n,t,r=null){let o=n.shape[0],p=n.shape[1];null!=r&&(o=r.shape[0],p=r.shape[1]);const d=a.backend_util.computeOptimalWindowSize(p),l={windowSize:d,inSize:p,batchSize:o,outSize:Math.ceil(p/d)},c=new s.l(l,t,null==r),u=[n];null!=r&&u.push(r);const h=e.runWebGLProgram(c,u,"int32");if(1===h.shape[1])return h;const m=i(e,n,t,h);return e.disposeIntermediateTensorInfo(h),m}function p(e,n,t,s=null){const o=null!=s?s.shape:n.shape,i=o[o.length-1],d=a.backend_util.computeOptimalWindowSize(i),l=new r.l(o,d,t,null==s),c=null==s?[n]:[n,s],u=e.runWebGLProgram(l,c,"int32");if(u.shape.length===n.shape.length){const a=p(e,n,t,u);return e.disposeIntermediateTensorInfo(u),a}return u}function d(e,n,t,s){const r=[t];if(a.backend_util.assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,n.shape.length),!(0,a._K2)().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const t=[],p=e.texData.get(n.dataId);let d=n;null!==p&&p.isPacked&&(d=e.unpackTensor(n),t.push(d));const[l,c]=a.backend_util.computeOutAndReduceShapes(d.shape,r),u=a.ZSL.sizeFromShape(c),h=(0,o.t)({inputs:{x:d},backend:e,attrs:{shape:[-1,u]}});t.push(h);const m=i(e,h,s);t.push(m);const b=(0,o.t)({inputs:{x:m},backend:e,attrs:{shape:l}});return t.forEach((n=>e.disposeIntermediateTensorInfo(n))),b}return p(e,n,s)}},15411:(e,n,t)=>{t.d(n,{Zt:()=>c,bE:()=>m,j0:()=>h,vi:()=>u});var a=t(36115),s=t(22897),r=t(46334),o=t(8993),i=t(66921),p=t(14899),d=t(68173),l=t(74890);const c="if (isnan(x)) return x;";function u({opSnippet:e,packedOpSnippet:n,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:i}=r,p=o,c=s||i.dtype;if(p.shouldExecuteOnCPU([i])&&null!=t){const e=p.texData.get(i.dataId),n=t(e.values,c);return p.makeTensorInfo(i.shape,c,n)}let u;return u=(0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new l.rf(i.shape,n):new d.hE(i.shape,e),p.runWebGLProgram(u,[i],c)}}function h({opSnippet:e,packedOpSnippet:n,checkOutOfBounds:t=!1,supportsComplex:i=!1,cpuKernelImpl:p,dtype:d}){return({inputs:l,backend:c})=>{const{a:u,b:h}=l,m=c;if(i&&"complex64"===u.dtype){const n=m.texData.get(u.dataId),t=m.texData.get(h.dataId),[r,i]=[[n.complexTensorInfos.real,t.complexTensorInfos.real],[n.complexTensorInfos.imag,t.complexTensorInfos.imag]].map((n=>{const[t,r]=n,o={dataId:t.dataId,dtype:t.dtype,shape:u.shape},i={dataId:r.dataId,dtype:r.dtype,shape:h.shape},p=new s.x(e,u.shape,h.shape);return m.runWebGLProgram(p,[o,i],(0,a.TuY)(t.dtype,r.dtype))})),p=(0,o.f)({inputs:{real:r,imag:i},backend:m});return m.disposeIntermediateTensorInfo(r),m.disposeIntermediateTensorInfo(i),p}const b=d||(0,a.TuY)(u.dtype,h.dtype);if(("string"===u.dtype||"string"===h.dtype||m.shouldExecuteOnCPU([u,h]))&&null!=p){const e=m.texData.get(u.dataId).values,n=m.texData.get(h.dataId).values,t="string"===u.dtype?a.backend_util.fromUint8ToStringArray(e):e,s="string"===u.dtype?a.backend_util.fromUint8ToStringArray(n):n,[r,o]=p(u.shape,h.shape,t,s,b),i=m.makeTensorInfo(o,b);return m.texData.get(i.dataId).values=r,i}let k;return k=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new r.VI(n,u.shape,h.shape,t):new s.x(e,u.shape,h.shape),m.runWebGLProgram(k,[u,h],b)}}function m(e,n=!1){if("linear"===e)return n?l._Q:d._Q;if("relu"===e)return n?l.X8:d.X8;if("elu"===e)return n?l.X0:d.X0;if("relu6"===e)return n?l.Nb:d.Nb;if("prelu"===e)return n?p.CN:p.DH;if("leakyrelu"===e)return n?i.aw:i.B1;if("sigmoid"===e)return n?l.Hq:d.Hq;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}},68754:(e,n,t)=>{t.d(n,{T:()=>o});var a=t(36115),s=t(89486),r=t(18541);function o(e,n,t,o){const i=function(e){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const t=n.length?n[n.length-1].outSize:e[1],s=a.backend_util.computeOptimalWindowSize(t);n.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return n}(e.shape);let p=e;for(let a=0;a<i.length;a++){const{inSize:d,windowSize:l,outSize:c}=i[a];let u,h;u="mean"===t?0===a?new s.C({windowSize:l,inSize:d,batchSize:e.shape[0],outSize:c},d):new s.C({windowSize:l,inSize:d,batchSize:e.shape[0],outSize:c}):new r.t({windowSize:l,inSize:d,batchSize:e.shape[0],outSize:c},t),h=p,p=o.runWebGLProgram(u,[p],n),h.dataId!==e.dataId&&o.disposeIntermediateTensorInfo(h)}return p}},76905:(e,n,t)=>{t.d(n,{$O:()=>q,AC:()=>x,BC:()=>G,BW:()=>f,CJ:()=>h,Dy:()=>S,E$:()=>c,G3:()=>P,G4:()=>L,Gs:()=>s,J3:()=>O,Kf:()=>i,LF:()=>Z,M_:()=>Y,Md:()=>p,Og:()=>A,Oy:()=>F,PP:()=>l,Q5:()=>j,QM:()=>b,S6:()=>$,SF:()=>u,Tm:()=>k,UC:()=>M,UF:()=>m,Xe:()=>y,ad:()=>_,cy:()=>K,dv:()=>d,f8:()=>C,fC:()=>D,fW:()=>V,h:()=>w,h0:()=>o,jm:()=>r,lL:()=>H,mo:()=>I,rI:()=>N,rQ:()=>T,rw:()=>v,sB:()=>z,tc:()=>W,uw:()=>g,vo:()=>R,we:()=>E,xt:()=>U,zN:()=>B});var a=t(6227);const{addImpl:s,bincountImpl:r,bincountReduceImpl:o,castImpl:i,ceilImpl:p,concatImpl:d,equalImpl:l,expImpl:c,expm1Impl:u,floorImpl:h,gatherNdImpl:m,gatherV2Impl:b,greaterImpl:k,greaterEqualImpl:f,lessImpl:g,lessEqualImpl:I,linSpaceImpl:x,logImpl:N,maxImpl:v,maximumImpl:S,minimumImpl:w,multiplyImpl:y,negImpl:T,notEqualImpl:_,prodImpl:A,raggedGatherImpl:L,raggedRangeImpl:F,raggedTensorToTensorImpl:P,rangeImpl:E,rsqrtImpl:W,scatterImpl:D,sigmoidImpl:G,simpleAbsImpl:C,sliceImpl:O,sparseFillEmptyRowsImpl:z,sparseReshapeImpl:R,sparseSegmentReductionImpl:B,sqrtImpl:Z,stridedSliceImpl:K,stringNGramsImpl:M,stringSplitImpl:$,stringToHashBucketFastImpl:V,subImpl:H,tileImpl:q,topKImpl:U,transposeImpl:j,uniqueImpl:Y}=a},65253:(e,n,t)=>{t.d(n,{l:()=>p});var a=t(36115),s=t(76905),r=t(68173),o=t(74890);const i="return abs(x);",p={kernelName:a.ljI,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{x:p}=n;if(t.shouldExecuteOnCPU([p])&&"complex64"!==p.dtype){const e=t.texData.get(p.dataId),n=(0,s.f8)(e.values);return t.makeTensorInfo(p.shape,p.dtype,n)}let d;return d=(0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new o.rf(p.shape,i):new r.hE(p.shape,i),t.runWebGLProgram(d,[p],p.dtype)}}},32019:(e,n,t)=>{t.d(n,{t:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.Vvy,backendName:"webgl",kernelFunc:o}},92619:(e,n,t)=>{t.d(n,{D:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.PH8,backendName:"webgl",kernelFunc:o}},8982:(e,n,t)=>{t.d(n,{U:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o="return a + b;",i=(0,s.j0)({opSnippet:o,packedOpSnippet:o,supportsComplex:!0,cpuKernelImpl:r.Gs}),p={kernelName:a.OMN,backendName:"webgl",kernelFunc:i}},40154:(e,n,t)=>{t.d(n,{y:()=>i});var a=t(36115),s=t(90212),r=t(31445),o=t(77723);const i={kernelName:a.EkD,backendName:"webgl",kernelFunc:function e(n){const{inputs:t,backend:i}=n,p=t;if(1===p.length)return(0,o.D)({inputs:{x:p[0]},backend:i});if(p.length>(0,a._K2)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(p.length/2),t=e({inputs:p.slice(0,n),backend:i}),a=e({inputs:p.slice(n),backend:i});return e({inputs:[t,a],backend:i})}const d=p.map((e=>e.dtype)).reduce(((e,n)=>(0,a.TuY)(e,n))),l=p.map((e=>e.shape)),c=(0,a._K2)().getBool("WEBGL_PACK")?new r.c(p[0].shape,l):new s.K(p[0].shape,l);return i.runWebGLProgram(c,p,d)}}},63990:(e,n,t)=>{t.d(n,{k:()=>i});var a=t(36115),s=t(68754),r=t(43008),o=t(58246);const i={kernelName:a.u8Z,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{axis:d,keepDims:l}=i,c=p.shape.length,u=a.ZSL.parseAxisParam(d,p.shape);let h=u;const m=a.backend_util.getAxesPermutation(h,c);let b=p;null!=m&&(b=(0,o.m)({inputs:{x:p},backend:t,attrs:{perm:m}}),h=a.backend_util.getInnerMostAxes(h.length,c)),a.backend_util.assertAxesAreInnerMostDims("all",h,c);const[k,f]=a.backend_util.computeOutAndReduceShapes(b.shape,h),g=a.ZSL.sizeFromShape(f),I=(0,r.t)({inputs:{x:b},backend:t,attrs:{shape:[-1,g]}}),x=(0,s.T)(I,I.dtype,"all",t);let N;if(l){const e=a.backend_util.expandShapeToKeepDim(k,u);N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:e}})}else N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:k}});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(x),null!=m&&t.disposeIntermediateTensorInfo(b),N}}},72335:(e,n,t)=>{t.d(n,{l:()=>i});var a=t(36115),s=t(68754),r=t(43008),o=t(58246);const i={kernelName:a.FSt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{axis:d,keepDims:l}=i,c=p.shape.length,u=a.ZSL.parseAxisParam(d,p.shape);let h=u;const m=a.backend_util.getAxesPermutation(h,c);let b=p;null!=m&&(b=(0,o.m)({inputs:{x:p},backend:t,attrs:{perm:m}}),h=a.backend_util.getInnerMostAxes(h.length,c)),a.backend_util.assertAxesAreInnerMostDims("any",h,c);const[k,f]=a.backend_util.computeOutAndReduceShapes(b.shape,h),g=a.ZSL.sizeFromShape(f),I=(0,r.t)({inputs:{x:b},backend:t,attrs:{shape:[-1,g]}}),x=(0,s.T)(I,I.dtype,"any",t);let N;if(l){const e=a.backend_util.expandShapeToKeepDim(k,u);N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:e}})}else N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:k}});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(x),null!=m&&t.disposeIntermediateTensorInfo(b),N}}},45247:(e,n,t)=>{t.d(n,{n:()=>o});var a=t(36115),s=t(73388),r=t(58246);const o={kernelName:a.Jp_,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{axis:p}=o;let d=a.ZSL.parseAxisParam(p,i.shape);const l=a.backend_util.getAxesPermutation(d,i.shape.length);let c=i;const u=[];null!=l&&(c=(0,r.m)({inputs:{x:i},backend:t,attrs:{perm:l}}),u.push(c),d=a.backend_util.getInnerMostAxes(d.length,c.shape.length)),a.backend_util.assertAxesAreInnerMostDims("argMax",[d[0]],c.shape.length);const h=(0,s.f)(t,c,d[0],"max");return u.forEach((e=>t.disposeIntermediateTensorInfo(e))),h}}},90085:(e,n,t)=>{t.d(n,{l:()=>o});var a=t(36115),s=t(73388),r=t(58246);const o={kernelName:a.p_m,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{axis:p}=o;let d=a.ZSL.parseAxisParam(p,i.shape);const l=a.backend_util.getAxesPermutation(d,i.shape.length);let c=i;const u=[];null!=l&&(c=(0,r.m)({inputs:{x:i},backend:t,attrs:{perm:l}}),u.push(c),d=a.backend_util.getInnerMostAxes(d.length,c.shape.length)),a.backend_util.assertAxesAreInnerMostDims("argMin",[d[0]],c.shape.length);const h=(0,s.f)(t,c,d[0],"min");return u.forEach((e=>t.disposeIntermediateTensorInfo(e))),h}}},1806:(e,n,t)=>{t.d(n,{S:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.QKF,backendName:"webgl",kernelFunc:o}},73844:(e,n,t)=>{t.d(n,{M:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"return log(x + sqrt(x * x + 1.0));",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.epO,backendName:"webgl",kernelFunc:o}},25007:(e,n,t)=>{t.d(n,{L:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  return atan(x);\n",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.TyE,backendName:"webgl",kernelFunc:o}},37913:(e,n,t)=>{t.d(n,{r:()=>l});var a=t(36115),s=t(22897),r=t(46334),o=t(15411);const i=s.dR+"\n  return atan(a, b);\n",p="\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+r.qq+"\n  return result;\n",d=(0,o.j0)({opSnippet:i,packedOpSnippet:p}),l={kernelName:a.lxb,backendName:"webgl",kernelFunc:d}},97743:(e,n,t)=>{t.d(n,{l:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.zP9,backendName:"webgl",kernelFunc:o}},21119:(e,n,t)=>{t.d(n,{R:()=>i});var a=t(36115),s=t(80297),r=t(88380),o=t(77723);const i={kernelName:a.ho8,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n;(0,r.CE)(p,"avgPool");const{filterSize:d,strides:l,pad:c,dimRoundingMode:u}=i;a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(l,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`));const h=a.backend_util.computePool2DInfo(p.shape,d,l,1,c,u);if(1===h.filterWidth&&1===h.filterHeight&&a.ZSL.arraysEqual(h.inShape,h.outShape))return(0,o.D)({inputs:{x:p},backend:t});const m=new s.h(h,"avg",!1);return t.runWebGLProgram(m,[p],"float32")}}},78060:(e,n,t)=>{t.d(n,{O:()=>r});var a=t(36115),s=t(80297);const r={kernelName:a.cS,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{filterSize:i,strides:p,pad:d,dimRoundingMode:l,dataFormat:c}=r,u=a.backend_util.computePool3DInfo(o.shape,i,p,[1,1,1],d,l,c),h=new s.U(u,"avg",!1);return t.runWebGLProgram(h,[o],"float32")}}},83312:(e,n,t)=>{t.d(n,{m:()=>r});var a=t(36115),s=t(94491);const r={kernelName:a.wwC,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{dy:o,input:i}=n,p=i,{filterSize:d,strides:l,pad:c,dimRoundingMode:u}=r,h=a.backend_util.computePool3DInfo(p.shape,d,l,[1,1,1],c,u),m=new s.q(h);return t.runWebGLProgram(m,[o],p.dtype)}}},84631:(e,n,t)=>{t.d(n,{$:()=>o});var a=t(36115),s=t(94491),r=t(88380);const o={kernelName:a.VCH,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{dy:i,input:p}=n,d=p;(0,r.CE)([i,p],"avgPoolGrad");const{filterSize:l,strides:c,pad:u}=o,h=a.backend_util.computePool2DInfo(d.shape,l,c,1,u),m=new s.x(h);return t.runWebGLProgram(m,[i],d.dtype)}}},8537:(e,n,t)=>{t.d(n,{X:()=>r});var a=t(36115),s=t(64374);const r={kernelName:a.jAQ,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{a:r,b:o}=n,{transposeA:i,transposeB:p}=a;return(0,s.L)({a:r,b:o,transposeA:i,transposeB:p,backend:t})}}},64374:(e,n,t)=>{t.d(n,{L:()=>c,U:()=>l});var a=t(36115),s=t(15411),r=t(63288),o=t(26041),i=t(43008),p=t(22853),d=t(58246);const l=1e3;function c({a:e,b:n,transposeA:t,transposeB:c,backend:u,bias:h=null,preluActivationWeights:m=null,leakyreluAlpha:b=0,activation:k=null}){const f=e.shape.length,g=n.shape.length,I=t?e.shape[f-2]:e.shape[f-1],x=c?n.shape[g-1]:n.shape[g-2],N=t?e.shape[f-1]:e.shape[f-2],v=c?n.shape[g-2]:n.shape[g-1],S=e.shape.slice(0,-2),w=n.shape.slice(0,-2),y=a.ZSL.sizeFromShape(S),T=a.ZSL.sizeFromShape(w),_=a.ZEY.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([N,v]);a.ZSL.assert(I===x,(()=>`Error in matMul: inner shapes (${I}) and (${x}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${t} and transposeB=${c} must match.`));const A=t?[y,I,N]:[y,N,I],L=c?[T,v,x]:[T,x,v],F=(0,i.t)({inputs:{x:e},backend:u,attrs:{shape:A}}),P=(0,i.t)({inputs:{x:n},backend:u,attrs:{shape:L}}),E=[F,P],W=Math.max(y,T),D=t?F.shape[1]:F.shape[2],G=null!=h,C=null!=m,O="leakyrelu"===k,z=null!=k?(0,s.bE)(k,!0):null;let R;if((1===N||1===v)&&D>l&&!1===(G||C||O||null!=z)){let e=F,n=P;t&&(e=(0,d.m)({inputs:{x:F},backend:u,attrs:{perm:[0,2,1]}}),E.push(e)),c&&(n=(0,d.m)({inputs:{x:P},backend:u,attrs:{perm:[0,2,1]}}),E.push(n));const a=1===v;let s=e;1!==v&&(s=(0,i.t)({inputs:{x:e},backend:u,attrs:{shape:[W,D,1]}}),E.push(s));const r=1===v?2:1;let l=n;a&&(l=(0,i.t)({inputs:{x:n},backend:u,attrs:{shape:[W,1,D]}}),E.push(l));const h=(0,o.l)({inputs:{a:s,b:l},backend:u});R=(0,p.c)({inputs:{x:h},backend:u,attrs:{axis:r,keepDims:!0}}),E.push(h)}else{const s=(0,a.TuY)(e.dtype,n.dtype),o=new r.P(A,L,[W,N,v],t,c,G,z,C,O),i=[F,P];if(null!=h&&i.push(h),C&&i.push(m),O){const e=u.makeTensorInfo([],"float32",a.ZSL.createScalarValue(b,"float32"));i.push(e),E.push(e)}R=u.runWebGLProgram(o,i,s)}const B=(0,i.t)({inputs:{x:R},backend:u,attrs:{shape:_}});E.push(R);for(const e of E)u.disposeIntermediateTensorInfo(e);return B}},82339:(e,n,t)=>{t.d(n,{V:()=>o});var a=t(36115),s=t(29643),r=t(68616);const o={kernelName:a.i5R,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:o,mean:i,variance:p,offset:d,scale:l}=e;a.ZSL.assert(i.shape.length===p.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.ZSL.assert(null==d||i.shape.length===d.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.ZSL.assert(null==l||i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=t;null==c&&(c=.001);const u=[o,i,p];let h=null;null!=d&&(h=d.shape,u.push(d));let m=null;null!=l&&(m=l.shape,u.push(l));const b=(0,a._K2)().getBool("WEBGL_PACK_NORMALIZATION")?new r.x(o.shape,i.shape,p.shape,h,m,c):new s.f(o.shape,i.shape,p.shape,h,m,c);return n.runWebGLProgram(b,u,u[0].dtype)}}},65514:(e,n,t)=>{t.d(n,{e:()=>i});var a=t(36115),s=t(43008),r=t(29547),o=t(58246);const i={kernelName:a.Ik2,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{blockShape:d,crops:l}=i;a.ZSL.assert(p.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const c=d.reduce(((e,n)=>e*n)),u=a.backend_util.getReshaped(p.shape,d,c),h=a.backend_util.getPermuted(u.length,d.length),m=a.backend_util.getReshapedPermuted(p.shape,d,c),b=a.backend_util.getSliceBeginCoords(l,d.length),k=a.backend_util.getSliceSize(m,l,d.length),f=[],g=(0,s.t)({inputs:{x:p},backend:t,attrs:{shape:u}}),I=(0,o.m)({inputs:{x:g},backend:t,attrs:{perm:h}}),x=(0,s.t)({inputs:{x:I},backend:t,attrs:{shape:m}}),N=(0,r.d)({inputs:{x},backend:t,attrs:{begin:b,size:k}});return f.push(g),f.push(I),f.push(x),f.forEach((e=>t.disposeIntermediateTensorInfo(e))),N}}},72517:(e,n,t)=>{t.d(n,{l:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.N4F,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r,weights:o}=n,{size:i}=a,p=t.readSync(r.dataId),d=t.readSync(o.dataId),l=(0,s.jm)(p,d,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,l)}}},36951:(e,n,t)=>{t.d(n,{N:()=>s});var a=t(36115);const s={kernelName:a.vj7,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{s0:s,s1:r}=n,o=t.readSync(s.dataId),i=t.readSync(r.dataId),p=a.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(i));return t.makeTensorInfo([p.length],"int32",Int32Array.from(p))}}},46227:(e,n,t)=>{t.d(n,{M:()=>l});var a=t(36115),s=t(76905),r=t(8993),o=t(77723),i=t(98890),p=t(4313),d=t(68173);const l={kernelName:a.KXH,backendName:"webgl",kernelFunc:function e(n){const{inputs:t,backend:l,attrs:c}=n,{x:u}=t,{dtype:h}=c;if("complex64"===h){if("complex64"===u.dtype)return(0,o.D)({inputs:{x:u},backend:l});const n=a.Ul9(u.shape),t=e({inputs:{x:u},backend:l,attrs:{dtype:"float32"}}),s=(0,r.f)({inputs:{real:t,imag:n},backend:l});return n.dispose(),l.disposeIntermediateTensorInfo(t),s}if("complex64"===u.dtype){const n=(0,p.x)({inputs:{input:u},backend:l}),t=e({inputs:{x:n},backend:l,attrs:{dtype:h}});return l.disposeIntermediateTensorInfo(n),t}if(!a.ZSL.hasEncodingLoss(u.dtype,h)){const e=(0,o.D)({inputs:{x:u},backend:l});return{dataId:e.dataId,shape:e.shape,dtype:h}}if(l.shouldExecuteOnCPU([u])){const e=l.texData.get(u.dataId).values,[n,t,a]=(0,s.Kf)(e,u.shape,u.dtype,h);return l.makeTensorInfo(n,t,a)}if("int32"===h)return function(e,n){const t=new d.hE(e.shape,"return float(int(x));"),a=n.runWebGLProgram(t,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(u,l);if("bool"===h){const e=l.makeTensorInfo([],"bool",a.ZSL.getTypedArrayFromDType("bool",1)),n={a:u,b:e},t=(0,i.E)({inputs:n,backend:l});return l.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${u.dtype} to ${h}`)}}},35960:(e,n,t)=>{t.d(n,{u:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o="return ceil(x);",i=(0,s.vi)({opSnippet:o,packedOpSnippet:o,cpuKernelImpl:r.Md}),p={kernelName:a.QDP,backendName:"webgl",kernelFunc:i}},47357:(e,n,t)=>{t.d(n,{F:()=>o});var a=t(36115),s=t(80273),r=t(9662);const o={kernelName:a.vaV,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{clipValueMin:p,clipValueMax:d}=o;let l;l=(0,a._K2)().getBool("WEBGL_PACK_CLIP")?new r.$(i.shape):new s.T(i.shape);const c=[[p],[d]];return t.runWebGLProgram(l,[i],i.dtype,c)}}},8993:(e,n,t)=>{t.d(n,{f:()=>r,v:()=>o});var a=t(36115),s=t(77723);function r(e){const{inputs:n,backend:t}=e,{real:a,imag:r}=n,o=t.makeTensorInfo(a.shape,"complex64"),i=t.texData.get(o.dataId),p=(0,s.D)({inputs:{x:a},backend:t}),d=(0,s.D)({inputs:{x:r},backend:t});return i.complexTensorInfos={real:p,imag:d},o}const o={kernelName:a.pr3,backendName:"webgl",kernelFunc:r}},37053:(e,n,t)=>{t.d(n,{t:()=>o});var a=t(36115),s=t(67282);function r(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}const o={kernelName:a.$zE,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{x:a}=n,o=t.texData.get(a.dataId),i=new s.t(a.shape),p=[r(a,o.complexTensorInfos.real),r(a,o.complexTensorInfos.imag)];return t.runWebGLProgram(i,p,p[0].dtype)}}},93179:(e,n,t)=>{t.d(n,{x:()=>b,V:()=>k});var a=t(36115),s=t(14151),r=t(82676),o=t(76905),i=t(68173),p=t(74890),d=t(8993),l=t(39803),c=t(4313),u=t(43008);function h(e,n,t){const m=e[0].dtype;if("complex64"===m){const a=e.map((e=>(0,c.x)({inputs:{input:e},backend:t}))),s=e.map((e=>(0,l.n)({inputs:{input:e},backend:t}))),r=h(a,n,t),o=h(s,n,t),i=(0,d.f)({inputs:{real:r,imag:o},backend:t});return a.forEach((e=>t.disposeIntermediateTensorInfo(e))),s.forEach((e=>t.disposeIntermediateTensorInfo(e))),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),i}let b=t.shouldExecuteOnCPU(e);if("string"===m&&(b=!0),b){const s=e.map((e=>{const s=[-1,a.ZSL.sizeFromShape(e.shape.slice(n))];return(0,u.t)({inputs:{x:e},backend:t,attrs:{shape:s}})})),r=s.map((e=>({vals:t.readSync(e.dataId),shape:e.shape}))),i=a.backend_util.computeOutShape(s.map((e=>e.shape)),1),p=1===s[0].shape[0],d=(0,o.dv)(r,i,m,p),l=a.backend_util.computeOutShape(e.map((e=>e.shape)),n),c=t.makeTensorInfo(l,m,d);return s.forEach((e=>t.disposeIntermediateTensorInfo(e))),c}const k=e.filter((e=>a.ZSL.sizeFromShape(e.shape)>0)),f=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&k[0].shape.length>1;if(1===k.length){const n=f?new i.hE(e[0].shape,i.UC):new p.rf(e[0].shape,i.UC);return t.runWebGLProgram(n,e,m)}const g=(0,a._K2)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(k.length>g){const e=[];for(let a=0;a<k.length;a+=g){const s=k.slice(a,a+g);e.push(h(s,n,t))}const a=h(e,n,t);for(const n of e)t.disposeIntermediateTensorInfo(n);return a}if(f){const e=new r.V(k.map((e=>e.shape)),n);return t.runWebGLProgram(e,k,m)}const{tensors2D:I,outShape:x}=function(e,n,t){const s=a.backend_util.computeOutShape(e.map((e=>e.shape)),n);return{tensors2D:e.map((e=>(0,u.t)({inputs:{x:e},attrs:{shape:[-1,a.ZSL.sizeFromShape(e.shape.slice(n))]},backend:t}))),outShape:s}}(k,n,t),N=new s.P(I.map((e=>e.shape))),v=t.runWebGLProgram(N,I,m);I.forEach((e=>t.disposeIntermediateTensorInfo(e)));const S=(0,u.t)({inputs:{x:v},attrs:{shape:x},backend:t});return t.disposeIntermediateTensorInfo(v),S}var m=t(77723);function b(e){const{inputs:n,backend:t,attrs:s}=e,{axis:r}=s,o=a.ZSL.parseAxisParam(r,n[0].shape)[0],i=n.map((e=>e.shape));a.backend_util.assertParamsConsistent(i,o);const p=a.backend_util.computeOutShape(n.map((e=>e.shape)),o);if(0===a.ZSL.sizeFromShape(p))return t.makeTensorInfo(p,n[0].dtype,[]);const d=n.filter((e=>a.ZSL.sizeFromShape(e.shape)>0));return 1===d.length?(0,m.D)({inputs:{x:d[0]},backend:t}):h(d,o,t)}const k={kernelName:a.$dB,backendName:"webgl",kernelFunc:b}},66045:(e,n,t)=>{t.d(n,{x:()=>p});var a=t(36115),s=t(21005),r=t(78762),o=t(53002),i=t(43008);const p={kernelName:a.p2J,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:p}=e,{x:d,filter:l}=n,{strides:c,pad:u,dataFormat:h,dilations:m,dimRoundingMode:b}=p,k=a.backend_util.convertConv2DDataFormat(h),f=a.backend_util.computeConv2DInfo(d.shape,l.shape,c,m,u,b,!1,k);let g;if(1!==f.filterHeight||1!==f.filterWidth||1!==f.dilationHeight||1!==f.dilationWidth||1!==f.strideHeight||1!==f.strideWidth||"SAME"!==f.padInfo.type&&"VALID"!==f.padInfo.type)if(f.strideWidth<=2&&"channelsLast"===k&&(0,a._K2)().getBool("WEBGL_EXP_CONV")){const e=new r.Z(f),n=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];g=t.runWebGLProgram(e,[d,l],"float32",n)}else if((0,a._K2)().getBool("WEBGL_CONV_IM2COL"))g=(0,o.J)({x:d,filter:l,convInfo:f,backend:t});else{const e=new s.B(f);g=t.runWebGLProgram(e,[d,l],"float32")}else g=(0,o.K)({x:d,filter:l,convInfo:f,backend:t});const I=(0,i.t)({inputs:{x:g},backend:t,attrs:{shape:f.outShape}});return t.disposeIntermediateTensorInfo(g),I}}},91241:(e,n,t)=>{t.d(n,{r:()=>r});var a=t(36115),s=t(3604);const r={kernelName:a.rFm,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o,dy:i}=n,{strides:p,pad:d,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=a.backend_util.convertConv2DDataFormat(l),m=a.backend_util.computeConv2DInfo(o.shape,u,p,1,d,c,!1,h),b=new s.S5(m);return t.runWebGLProgram(b,[o,i],"float32")}}},4879:(e,n,t)=>{t.d(n,{f:()=>r});var a=t(36115),s=t(3604);const r={kernelName:a.jfg,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:i}=n,{inputShape:p,strides:d,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=a.backend_util.convertConv2DDataFormat(c),m=a.backend_util.computeConv2DInfo(p,i.shape,d,1,l,u,!1,h),b=new s.eS(m);return t.runWebGLProgram(b,[o,i],"float32")}}},53002:(e,n,t)=>{t.d(n,{J:()=>h,K:()=>u});var a=t(36115),s=t(58638),r=t(15411),o=t(63288),i=t(88380),p=t(64374),d=t(77723),l=t(43008);function c(e,n){const t=e.length;return t>=3?n?[...e.slice(0,-3),e[t-3]*e[t-2],e[t-1]]:[...e.slice(0,-3),e[t-3],e[t-2]*e[t-1]]:!n&&1===t&&e[0]>1?[e[0],1]:null}function u({x:e,filter:n,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:h=null}){const m=e.shape,b=s.texData.get(e.dataId),k=t.inChannels,f=m[0]*m[1]*m[2],g=t.outChannels,I="channelsLast"===t.dataFormat;let x;const N=[];if(null!=o){const e=c(o.shape,I);null!=e&&(o=(0,l.t)({inputs:{x:o},backend:s,attrs:{shape:e}}),N.push(o))}if(null!=r){const e=c(r.shape,I);null!=e&&(r=(0,l.t)({inputs:{x:r},backend:s,attrs:{shape:e}}),N.push(r))}if((1!==f&&1!==g||!(k>p.U))&&b.isPacked&&I&&null!=b.texture&&m[2]%2!=0&&a.ZSL.arraysEqual(b.shape.slice(-3),m.slice(-3))){const c=m[0]*m[1]*(m[2]+1),k={dataId:e.dataId,shape:[1,c,t.inChannels],dtype:e.dtype},f=b.shape;b.shape=b.shape.slice(),b.shape[b.shape.length-2]++,a.ZSL.assert(i.P0(b.shape,k.shape),(()=>`packed reshape ${b.shape} to ${k.shape} isn't free`));const g=(0,l.t)({inputs:{x:n},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});N.push(g);const I=(0,p.L)({a:k,b:g,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:h,preluActivationWeights:o,leakyreluAlpha:u}),v=s.texData.get(I.dataId);a.ZSL.assert(v.isPacked,(()=>"batchMatMul result is expected to be packed")),b.shape=f,v.shape=t.outShape,x=(0,d.D)({inputs:{x:I},backend:s}),x.shape=t.outShape,N.push(I)}else{const a=t.outHeight*t.outWidth,i=(0,l.t)({inputs:{x:e},backend:s,attrs:{shape:I?[t.batchSize,a,t.inChannels]:[t.batchSize,t.inChannels,a]}}),d=(0,l.t)({inputs:{x:n},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),c=(0,p.L)({a:I?i:d,b:I?d:i,transposeA:!I,transposeB:!1,backend:s,bias:r,activation:h,preluActivationWeights:o,leakyreluAlpha:u});x=(0,l.t)({inputs:{x:c},backend:s,attrs:{shape:t.outShape}}),N.push(i),N.push(d),N.push(c)}for(const e of N)s.disposeIntermediateTensorInfo(e);return x}function h({x:e,filter:n,convInfo:t,backend:i,bias:p=null,preluActivationWeights:d=null,leakyreluAlpha:u=0,activation:h=null}){const{filterWidth:m,filterHeight:b,inChannels:k,outWidth:f,outHeight:g,dataFormat:I}=t,x="channelsLast"===I,N=m*b*k,v=g*f,S=[t.batchSize,N,v],w=[];if(null!=d){const e=c(d.shape,x);null!=e&&(d=(0,l.t)({inputs:{x:d},backend:i,attrs:{shape:e}}),w.push(d))}if(null!=p){const e=c(p.shape,x);null!=e&&(p=(0,l.t)({inputs:{x:p},backend:i,attrs:{shape:e}}),w.push(p))}const y=(0,l.t)({inputs:{x:n},backend:i,attrs:{shape:[1,N,a.ZSL.sizeFromShape(n.shape)/N]}});w.push(y);const T=new s.D(S,t),_=[e.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=i.runWebGLProgram(T,[e],"float32",_),L=(0,l.t)({inputs:{x:A},backend:i,attrs:{shape:S}});w.push(A),w.push(L);const F=null!=p,P=null!=d,E="leakyrelu"===h,W=h?(0,r.bE)(h,!0):null,D=new o.P(x?L.shape:y.shape,x?y.shape:L.shape,x?[t.batchSize,v,t.outChannels]:[t.batchSize,t.outChannels,v],!0,!1,F,W,P,E),G=x?[L,y]:[y,L];if(p&&G.push(p),P&&G.push(d),E){const e=i.makeTensorInfo([],"float32",a.ZSL.createScalarValue(u,"float32"));G.push(e),w.push(e)}const C=i.runWebGLProgram(D,G,"float32"),O=(0,l.t)({inputs:{x:C},backend:i,attrs:{shape:t.outShape}});w.push(C);for(const e of w)i.disposeIntermediateTensorInfo(e);return O}},14992:(e,n,t)=>{t.d(n,{i:()=>r});var a=t(36115),s=t(21005);const r={kernelName:a.A1h,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o,filter:i}=n,{strides:p,pad:d,dilations:l}=r,c=a.backend_util.computeConv3DInfo(o.shape,i.shape,p,l,d),u=new s.w(c);return t.runWebGLProgram(u,[o,i],"float32")}}},7664:(e,n,t)=>{t.d(n,{i:()=>r});var a=t(36115),s=t(3604);const r={kernelName:a.iGz,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o,dy:i}=n,{strides:p,pad:d,filterShape:l}=r,c=a.backend_util.computeConv3DInfo(o.shape,l,p,1,d),u=new s.N7(c);return t.runWebGLProgram(u,[o,i],"float32")}}},94948:(e,n,t)=>{t.d(n,{Y:()=>r});var a=t(36115),s=t(3604);const r={kernelName:a.gC7,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:i}=n,{pad:p,strides:d,inputShape:l}=r,c=a.backend_util.computeConv3DInfo(l,i.shape,d,1,p),u=new s.tR(c);return t.runWebGLProgram(u,[o,i],"float32")}}},15354:(e,n,t)=>{t.d(n,{o:()=>i});var a=t(36115),s=t(15411);const r=s.Zt+"\n  return cos(x);\n",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.Mn0,backendName:"webgl",kernelFunc:o}},86856:(e,n,t)=>{t.d(n,{k:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),r={kernelName:a.MnK,backendName:"webgl",kernelFunc:s}},16998:(e,n,t)=>{t.d(n,{O:()=>r});var a=t(36115),s=t(59396);const r={kernelName:a.MRQ,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:a}=e,{image:r,boxes:o,boxInd:i}=n,{cropSize:p,method:d,extrapolationValue:l}=a,c=new s.c(r.shape,o.shape,p,d,l);return t.runWebGLProgram(c,[r,o,i],"float32")}}},36511:(e,n,t)=>{t.d(n,{G:()=>i});var a=t(36115),s=t(76434),r=t(77723),o=t(58246);function i(e,n,t,i,p,d){const l=n.shape.length,c=a.backend_util.getAxesPermutation([i],l);let u=n;null!=c&&(u=(0,o.m)({inputs:{x:n},backend:t,attrs:{perm:c}}));const h=a.backend_util.getInnerMostAxes(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${i}`);const m=u.shape[h];let b=(0,r.D)({inputs:{x:u},backend:t});for(let n=0;n<=Math.ceil(Math.log2(m))-1;n++){const a=new s.G(e,u.shape,!1,d),r=[[n]],o=b;b=t.runWebGLProgram(a,[b],b.dtype,r),t.disposeIntermediateTensorInfo(o)}if(p){const n=new s.G(e,u.shape,p,d),a=b;b=t.runWebGLProgram(n,[b],b.dtype),t.disposeIntermediateTensorInfo(a)}if(null!=c){const e=a.backend_util.getUndoAxesPermutation(c),n=(0,o.m)({inputs:{x:b},backend:t,attrs:{perm:e}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(u),n}return b}},97591:(e,n,t)=>{t.d(n,{T:()=>o});var a=t(36115),s=t(76434),r=t(36511);const o={kernelName:a.jj_,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o}=n,{axis:i,exclusive:p,reverse:d}=a;return(0,r.G)(s.z.Prod,o,t,i,p,d)}}},5171:(e,n,t)=>{t.d(n,{$:()=>o});var a=t(36115),s=t(76434),r=t(36511);const o={kernelName:a.nY8,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o}=n,{axis:i,exclusive:p,reverse:d}=a;return(0,r.G)(s.z.Sum,o,t,i,p,d)}}},99590:(e,n,t)=>{t.d(n,{Y:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.wNW,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r,weights:o}=n,{size:i,binaryOutput:p}=a;if(1===r.shape.length){const e=t.readSync(r.dataId),n=t.readSync(o.dataId),a=(0,s.jm)(e,n,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,a)}if(2===r.shape.length){const e=t.bufferSync(r),n=t.bufferSync(o),a=(0,s.h0)(e,n,i,p);return t.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}}},46355:(e,n,t)=>{t.d(n,{R:()=>r});var a=t(36115),s=t(34673);const r={kernelName:a.TMz,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r}=n,{blockSize:o,dataFormat:i}=a,p=r.shape[0],d=("NHWC"===i?r.shape[1]:r.shape[2])*o,l=("NHWC"===i?r.shape[2]:r.shape[3])*o,c=("NHWC"===i?r.shape[3]:r.shape[1])/(o*o),u="NHWC"===i?[p,d,l,c]:[p,c,d,l],h=new s.x(u,o,i);return t.runWebGLProgram(h,[r],r.dtype)}}},14947:(e,n,t)=>{t.d(n,{v:()=>o});var a=t(36115),s=t(4999),r=t(10424);const o={kernelName:a.tGH,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{x:i,filter:p}=n,{strides:d,pad:l,dilations:c,dimRoundingMode:u}=o;let h=c;null==h&&(h=[1,1]),a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(d,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${h}'`));const m=a.backend_util.computeConv2DInfo(i.shape,p.shape,d,h,l,u,!0);let b;b=(0,a._K2)().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1?new r.K(m):new s.E(m);const k=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];return t.runWebGLProgram(b,[i,p],"float32",k)}}},86099:(e,n,t)=>{t.d(n,{n:()=>r});var a=t(36115),s=t(52966);const r={kernelName:a.X$8,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o,dy:i}=n,{strides:p,dilations:d,pad:l,dimRoundingMode:c,filterShape:u}=r,h=a.backend_util.computeConv2DInfo(o.shape,u,p,d,l,c,!0),m=new s.f(h);return t.runWebGLProgram(m,[o,i],"float32")}}},48689:(e,n,t)=>{t.d(n,{V:()=>r});var a=t(36115),s=t(52966);const r={kernelName:a.nVu,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:i}=n,{strides:p,dilations:d,pad:l,dimRoundingMode:c,inputShape:u}=r,h=a.backend_util.computeConv2DInfo(u,i.shape,p,d,l,c,!0),m=new s.R(h);return t.runWebGLProgram(m,[o,i],"float32")}}},7530:(e,n,t)=>{t.d(n,{O:()=>o});var a=t(36115),s=t(32068),r=t(43008);const o={kernelName:a.ORI,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{x:o}=n,i=[...o.shape,...o.shape],p=a.ZSL.sizeFromShape(o.shape),d=(0,r.t)({inputs:{x:o},backend:t,attrs:{shape:[p]}}),l=new s.e(p),c=t.runWebGLProgram(l,[d],d.dtype),u=(0,r.t)({inputs:{x:c},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(c),u}}},31345:(e,n,t)=>{t.d(n,{F:()=>o});var a=t(36115),s=t(79229),r=t(43008);const o={kernelName:a.jxD,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{x:i,filter:p}=n,{strides:d,pad:l,dilations:c}=o,u=a.backend_util.computeDilation2DInfo(i.shape,p.shape,d,l,"NHWC",c);let h;const m=new s.x(u);h=t.runWebGLProgram(m,[i,p],"float32");const b=(0,r.t)({inputs:{x:h},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(h),b}}},72718:(e,n,t)=>{t.d(n,{_:()=>p});var a=t(36115),s=t(26041),r=t(43008),o=t(22853),i=t(58246);const p={kernelName:a.Qgm,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:p}=e,{equation:d}=p,l=n,{allDims:c,summedDims:u,idDims:h}=a.backend_util.decodeEinsumEquation(d,l.length);a.backend_util.checkEinsumDimSizes(c.length,h,l);const{path:m,steps:b}=a.backend_util.getEinsumComputePath(u,h),k=b.length;let f=null,g=c.length;const I=[];for(let e=0;e<k;++e){for(const n of b[e]){const{permutationIndices:e,expandDims:o}=a.backend_util.getEinsumPermutation(g,h[n]);let p;a.backend_util.isIdentityPermutation(e)?p=l[n]:(p=(0,i.m)({inputs:{x:l[n]},backend:t,attrs:{perm:e}}),I.push(p));const d=p.shape.slice();for(let e=0;e<o.length;++e)d.splice(o[e],0,1);a.ZSL.arraysEqual(p.shape,d)||(p=(0,r.t)({inputs:{x:p},backend:t,attrs:{shape:d}}),I.push(p)),null===f?f=p:(f=(0,s.l)({inputs:{a:p,b:f},backend:t}),I.push(f))}e<k-1&&(m[e]>=0&&(f=(0,o.c)({inputs:{x:f},backend:t,attrs:{axis:m[e]-(c.length-g),keepDims:!1}}),I.push(f)),g--)}for(const e of I)e!==f&&t.disposeIntermediateTensorInfo(e);return f}}},46321:(e,n,t)=>{t.d(n,{J:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),r={kernelName:a.Pah,backendName:"webgl",kernelFunc:s}},93057:(e,n,t)=>{t.d(n,{x:()=>o});var a=t(36115),s=t(22897),r=t(46334);const o={kernelName:a.rsH,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t}=e,{dy:o,y:i}=n,p=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new r.VI("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",o.shape,i.shape):new s.x("return (b >= 1.0) ? a : a * (b + 1.0);",o.shape,i.shape);return t.runWebGLProgram(p,[o,i],o.dtype)}}},73525:(e,n,t)=>{t.d(n,{R:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.j0)({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:r.PP}),i={kernelName:a.BRl,backendName:"webgl",kernelFunc:o}},83910:(e,n,t)=>{t.d(n,{_:()=>i});var a=t(36115),s=t(15411);const r=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${a.backend_util.ERF_P};\n  float a1 = ${a.backend_util.ERF_A1};\n  float a2 = ${a.backend_util.ERF_A2};\n  float a3 = ${a.backend_util.ERF_A3};\n  float a4 = ${a.backend_util.ERF_A4};\n  float a5 = ${a.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,o=(0,s.vi)({opSnippet:r}),i={kernelName:a._s9,backendName:"webgl",kernelFunc:o}},29450:(e,n,t)=>{t.d(n,{AC:()=>p,oN:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=s.Zt+"\n  return exp(x);\n",i=(0,s.vi)({opSnippet:o,packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:r.E$,dtype:"float32"}),p={kernelName:a.ox3,backendName:"webgl",kernelFunc:i}},98134:(e,n,t)=>{t.d(n,{U:()=>r,a:()=>o});var a=t(36115),s=t(43008);function r(e){const{inputs:n,attrs:t,backend:r}=e,{dim:o}=t,{input:i}=n,p=i.shape.length,d=i.shape.slice();let l=o;return o<0&&(a.ZSL.assert(-(p+1)<=o,(()=>`Axis must be in the interval [${-(p+1)}, ${p}]`)),l=p+o+1),d.splice(l,0,1),(0,s.t)({inputs:{x:i},backend:r,attrs:{shape:d}})}const o={kernelName:a.ybN,backendName:"webgl",kernelFunc:r}},70324:(e,n,t)=>{t.d(n,{Y:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o="return exp(x) - 1.0;",i=(0,s.vi)({opSnippet:o,packedOpSnippet:o,cpuKernelImpl:r.SF}),p={kernelName:a.ybj,backendName:"webgl",kernelFunc:i}},89805:(e,n,t)=>{t.d(n,{N:()=>r});var a=t(36115),s=t(98074);const r={kernelName:a.rGP,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{input:a}=n;return(0,s.J)(a,!1,t)}}},98074:(e,n,t)=>{t.d(n,{J:()=>i});var a=t(36115),s=t(49873),r=t(8993),o=t(43008);function i(e,n,t){const i=t.texData.get(e.dataId),p=a.ZSL.sizeFromShape(e.shape),d=e.shape[e.shape.length-1],l=p/d,c=(0,o.t)({inputs:{x:e},backend:t,attrs:{shape:[l,d]}}),u=c.shape,h=new s.R("real",u,n),m=new s.R("imag",u,n),b=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:u},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:u}],k=t.runWebGLProgram(h,b,"float32"),f=t.runWebGLProgram(m,b,"float32"),g=(0,r.f)({inputs:{real:k,imag:f},backend:t});t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(f);const I=(0,o.t)({inputs:{x:g},backend:t,attrs:{shape:e.shape}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(g),I}},37664:(e,n,t)=>{t.d(n,{G:()=>r,u:()=>o});var a=t(36115),s=t(27906);function r(e){const{backend:n,attrs:t}=e,{shape:r,value:o}=t;let{dtype:i}=t;if(i=i||a.ZSL.inferDtype(o),"string"===i){const e=a.ZSL.getArrayFromDType(i,a.ZSL.sizeFromShape(r));return e.fill(o),n.makeTensorInfo(r,i,e)}{const e=new s.w(r,o),t=[[o]];return n.runWebGLProgram(e,[],i,t)}}const o={kernelName:a.SQl,backendName:"webgl",kernelFunc:r}},99893:(e,n,t)=>{t.d(n,{D:()=>r});var a=t(36115),s=t(54057);const r={kernelName:a.BxF,backendName:"webgl",kernelFunc:({inputs:e,backend:n})=>{const{image:t}=e,a=n,r=new s.T(t.shape);return a.runWebGLProgram(r,[t],t.dtype)}}},54087:(e,n,t)=>{t.d(n,{H:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o="return floor(x);",i=(0,s.vi)({opSnippet:o,packedOpSnippet:o,cpuKernelImpl:r.CJ}),p={kernelName:a.ZgB,backendName:"webgl",kernelFunc:i}},15328:(e,n,t)=>{t.d(n,{U:()=>r});var a=t(36115);const s=(0,t(15411).j0)({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),r={kernelName:a.ElG,backendName:"webgl",kernelFunc:s}},16386:(e,n,t)=>{t.d(n,{y:()=>p});var a=t(36115),s=t(28560),r=t(18765);class o{constructor(e){this.variableNames=["A"];const n=(0,r.B)(),[t,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${t}.0);\n\n        vec4 values = ${n.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class i{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=(0,r.B)(),[t,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${t}.0);\n            vec4 values = ${n.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${n.output} = result;\n      }\n    `}}const p={kernelName:a.awo,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e;let{pixels:p}=n;const{numChannels:c}=r,u="undefined"!=typeof HTMLVideoElement&&p instanceof HTMLVideoElement,h="undefined"!=typeof HTMLImageElement&&p instanceof HTMLImageElement,[m,b]=u?[p.videoWidth,p.videoHeight]:[p.width,p.height],k=[b,m],f=[b,m,c];if(h||u){const e=(0,a._K2)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=d&&e===l||(l=e,d=document.createElement("canvas").getContext("2d",{willReadFrequently:l})),d.canvas.width=m,d.canvas.height=b,d.drawImage(p,0,0,m,b),p=d.canvas}const g=t.makeTensorInfo(k,"int32");t.texData.get(g.dataId).usage=s.tT.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(g.dataId),p);const I=(0,a._K2)().getBool("WEBGL_PACK")?new i(f):new o(f),x=t.runWebGLProgram(I,[g],"int32");return t.disposeData(g.dataId),x}};let d,l=(0,a._K2)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU")},39882:(e,n,t)=>{t.d(n,{q:()=>d});var a=t(36115),s=t(21005),r=t(78762),o=t(15411),i=t(53002),p=t(43008);const d={kernelName:a.aAr,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:d}=e,{x:l,filter:c,bias:u,preluActivationWeights:h}=n,{strides:m,pad:b,dataFormat:k,dilations:f,dimRoundingMode:g,activation:I,leakyreluAlpha:x}=d,N=a.backend_util.convertConv2DDataFormat(k),v=a.backend_util.computeConv2DInfo(l.shape,c.shape,m,f,b,g,!1,N);let S;const w=[],y=null!=u,T=null!=h,_="leakyrelu"===I,A=()=>{const e=[l,c],n=(e,n)=>{if("NCHW"===n&&1===e.shape.length&&1!==e.shape[0]){const n=(0,p.t)({inputs:{x:e},backend:t,attrs:{shape:[e.shape[0],1,1]}});return w.push(n),n}return e};if(y&&e.push(n(u,k)),T&&e.push(n(h,k)),_){const n=t.makeTensorInfo([],"float32",a.ZSL.createScalarValue(x,"float32"));e.push(n),w.push(n)}return e};if(1!==v.filterHeight||1!==v.filterWidth||1!==v.dilationHeight||1!==v.dilationWidth||1!==v.strideHeight||1!==v.strideWidth||"SAME"!==v.padInfo.type&&"VALID"!==v.padInfo.type)if(v.strideWidth<=2&&"channelsLast"===N&&(0,a._K2)().getBool("WEBGL_EXP_CONV")){const e=I?(0,o.bE)(I,!0):null,n=new r.Z(v,y,e,T,_),a=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],s=A();S=t.runWebGLProgram(n,s,"float32",a)}else if((0,a._K2)().getBool("WEBGL_CONV_IM2COL"))S=(0,i.J)({x:l,filter:c,convInfo:v,backend:t,bias:u,activation:I,preluActivationWeights:h,leakyreluAlpha:x});else{const e=I?(0,o.bE)(I,!1):null,n=new s.B(v,y,e,T,_),a=A();S=t.runWebGLProgram(n,a,"float32")}else S=(0,i.K)({x:l,filter:c,convInfo:v,backend:t,bias:u,activation:I,preluActivationWeights:h,leakyreluAlpha:x});const L=(0,p.t)({inputs:{x:S},backend:t,attrs:{shape:v.outShape}});return w.push(S),w.forEach((e=>t.disposeIntermediateTensorInfo(e))),L}}},65057:(e,n,t)=>{t.d(n,{l:()=>i});var a=t(36115),s=t(4999),r=t(10424),o=t(15411);const i={kernelName:a.T7M,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p,filter:d,bias:l,preluActivationWeights:c}=n,{strides:u,pad:h,dilations:m,dimRoundingMode:b,activation:k,leakyreluAlpha:f}=i,g=[];let I=m;null==I&&(I=[1,1]),a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,I),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${I}'`));const x=a.backend_util.computeConv2DInfo(p.shape,d.shape,u,I,h,b,!0),N=(0,a._K2)().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels==1,v=k?(0,o.bE)(k,N):null,S=[p,d],w=null!=l,y=null!=c,T="leakyrelu"===k;if(w&&S.push(l),y&&S.push(c),T){const e=t.makeTensorInfo([],"float32",a.ZSL.createScalarValue(f,"float32"));S.push(e),g.push(e)}let _;_=N?new r.K(x,w,v,y,T):new s.E(x,w,v,y,T);const A=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],L=t.runWebGLProgram(_,S,"float32",A);return g.forEach((e=>t.disposeIntermediateTensorInfo(e))),L}}},66900:(e,n,t)=>{t.d(n,{K:()=>i});var a=t(36115),s=t(96911),r=t(76905),o=t(43008);const i={kernelName:a.O4G,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{params:i,indices:p}=n,d=p.shape,l=d[d.length-1],c=a.ZSL.sizeFromShape(i.shape),[u,h,m,b]=a.backend_util.prepareAndValidate(i,p),k=(0,o.t)({inputs:{x:p},backend:t,attrs:{shape:[h,l]}}),f=(0,o.t)({inputs:{x:i},backend:t,attrs:{shape:[a.ZSL.sizeFromShape(i.shape)/m,m]}});if(t.shouldExecuteOnCPU([i,p])||"string"===i.dtype){const e=t.readSync(p.dataId),n=t.bufferSync(i),a=(0,r.UF)(e,n,i.dtype,h,l,m,b,i.shape,c);return t.makeTensorInfo(u,i.dtype,a.values)}const g=new s.g(l,b,[h,m],i.shape),I=t.runWebGLProgram(g,[f,k],f.dtype),x=(0,o.t)({inputs:{x:I},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(I),x}}},23706:(e,n,t)=>{t.d(n,{C:()=>i,a:()=>p});var a=t(36115),s=t(60432),r=t(76905),o=t(43008);function i(e){const{inputs:n,backend:t,attrs:i}=e,{x:p,indices:d}=n,{axis:l,batchDims:c}=i,u=a.ZSL.parseAxisParam(l,p.shape)[0];if((0,a._K2)().get("DEBUG")){const e=t.readSync(d.dataId),n=p.shape[u];for(let t=0;t<e.length;++t){const s=e[t];a.ZSL.assert(s<=n-1&&s>=0,(()=>`GatherV2: the index value ${s} is not in [0, ${n-1}]`))}}const h=a.backend_util.segment_util.collectGatherOpShapeInfo(p,d,u,c),m=a.ZSL.sizeFromShape(d.shape),b=[],k=(0,o.t)({inputs:{x:p},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),f=(0,o.t)({inputs:{x:d},backend:t,attrs:{shape:[h.batchSize,m/h.batchSize]}});b.push(k),b.push(f);const g=[h.batchSize,h.outerSize,m/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([p,d])||"string"===p.dtype){const e=t.bufferSync(f),n=t.bufferSync(k),a=(0,r.QM)(n,e,g);return b.forEach((e=>t.disposeIntermediateTensorInfo(e))),t.makeTensorInfo(h.outputShape,a.dtype,a.values)}const I=new s.u(k.shape,g),x=t.runWebGLProgram(I,[k,f],k.dtype);b.push(x);const N=(0,o.t)({inputs:{x},backend:t,attrs:{shape:h.outputShape}});return b.forEach((e=>t.disposeIntermediateTensorInfo(e))),N}const p={kernelName:a.mxL,backendName:"webgl",kernelFunc:i}},95171:(e,n,t)=>{t.d(n,{x:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.j0)({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:r.Tm,dtype:"bool"}),i={kernelName:a.XhZ,backendName:"webgl",kernelFunc:o}},379:(e,n,t)=>{t.d(n,{V:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.j0)({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:r.BW}),i={kernelName:a.lLS,backendName:"webgl",kernelFunc:o}},66696:(e,n,t)=>{t.d(n,{c:()=>r});var a=t(36115),s=t(98074);const r={kernelName:a.OAQ,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{input:a}=n;return(0,s.J)(a,!0,t)}}},77723:(e,n,t)=>{function a(e){const{inputs:n,backend:t}=e,{x:a}=n;return t.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}t.d(n,{D:()=>a,F:()=>s});const s={kernelName:t(36115).lzr,backendName:"webgl",kernelFunc:a}},39803:(e,n,t)=>{t.d(n,{l:()=>o,n:()=>r});var a=t(36115),s=t(77723);function r(e){const{inputs:n,backend:t}=e,{input:a}=n,r=t.texData.get(a.dataId);return(0,s.D)({inputs:{x:r.complexTensorInfos.imag},backend:t})}const o={kernelName:a.dv8,backendName:"webgl",kernelFunc:r}},83834:(e,n,t)=>{t.d(n,{K:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),r={kernelName:a.gIW,backendName:"webgl",kernelFunc:s}},95442:(e,n,t)=>{t.d(n,{I:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return float(isinf(x));",dtype:"bool"}),r={kernelName:a.E3$,backendName:"webgl",kernelFunc:s}},3872:(e,n,t)=>{t.d(n,{I:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return float(isnan(x));",dtype:"bool"}),r={kernelName:a.iPs,backendName:"webgl",kernelFunc:s}},6489:(e,n,t)=>{t.d(n,{x:()=>o});var a=t(36115),s=t(66501),r=t(19314);const o={kernelName:a.jM4,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{depthRadius:p,bias:d,alpha:l,beta:c}=o,u=(0,a._K2)().getBool("WEBGL_PACK_NORMALIZATION")?new r.f(i.shape,p,d,l,c):new s.F(i.shape,p,d,l,c);return t.runWebGLProgram(u,[i],i.dtype)}}},89193:(e,n,t)=>{t.d(n,{j:()=>r});var a=t(36115),s=t(96146);const r={kernelName:a.ToN,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:a}=e,{x:r,y:o,dy:i}=n,{depthRadius:p,bias:d,alpha:l,beta:c}=a,u=new s.j(r.shape,p,d,l,c);return t.runWebGLProgram(u,[r,o,i],r.dtype)}}},66921:(e,n,t)=>{t.d(n,{B1:()=>o,aw:()=>i,zp:()=>p});var a=t(36115),s=t(22897),r=t(46334);const o="return (a < 0.) ? b * a : a;",i="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",p={kernelName:a.X0$,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:p}=e,{x:d}=n,{alpha:l}=p,c=t.makeTensorInfo([],"float32",a.ZSL.createScalarValue(l,"float32")),u=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new r.VI(i,d.shape,c.shape):new s.x(o,d.shape,c.shape),h=t.runWebGLProgram(u,[d,c],"float32");return t.disposeIntermediateTensorInfo(c),h}}},26132:(e,n,t)=>{t.d(n,{Y:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.j0)({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:r.uw,dtype:"bool"}),i={kernelName:a.mIA,backendName:"webgl",kernelFunc:o}},4094:(e,n,t)=>{t.d(n,{Q:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.j0)({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:r.mo,dtype:"bool"}),i={kernelName:a.CwD,backendName:"webgl",kernelFunc:o}},22970:(e,n,t)=>{t.d(n,{o:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.mnI,backendName:"webgl",kernelFunc:function(e){const{backend:n,attrs:t}=e,{start:a,stop:r,num:o}=t,i=(0,s.AC)(a,r,o);return n.makeTensorInfo([i.length],"float32",i)}}},71739:(e,n,t)=>{t.d(n,{F:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o=s.Zt+"\n  return x < 0.0 ? 0./0. : log(x);\n",i=(0,s.vi)({opSnippet:o,packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:r.rI}),p={kernelName:a.tG8,backendName:"webgl",kernelFunc:i}},12462:(e,n,t)=>{t.d(n,{W:()=>i});var a=t(36115),s=t(15411);const r=s.Zt+"\n  return log(1.0 + x);\n",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.Cg$,backendName:"webgl",kernelFunc:o}},57133:(e,n,t)=>{t.d(n,{V:()=>r});var a=t(36115);const s=(0,t(15411).j0)({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),r={kernelName:a.RUm,backendName:"webgl",kernelFunc:s}},4873:(e,n,t)=>{t.d(n,{f:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return float(!(x >= 1.0));"}),r={kernelName:a.nZd,backendName:"webgl",kernelFunc:s}},10695:(e,n,t)=>{t.d(n,{r:()=>r});var a=t(36115);const s=(0,t(15411).j0)({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),r={kernelName:a.LXA,backendName:"webgl",kernelFunc:s}},99160:(e,n,t)=>{t.d(n,{T:()=>p,l:()=>d});var a=t(36115),s=t(76905),r=t(68754),o=t(43008),i=t(89523);function p(e){const{inputs:n,backend:t,attrs:p}=e,{x:d}=n,{reductionIndices:l,keepDims:c}=p,u=d.shape.length,h=a.ZSL.parseAxisParam(l,d.shape);let m=h;const b=a.backend_util.getAxesPermutation(m,u),k=null!=b,f=t.shouldExecuteOnCPU([d]);let g=d;if(k){if(f){const e=t.texData.get(g.dataId).values,n=new Array(u);for(let e=0;e<n.length;e++)n[e]=d.shape[b[e]];const a=(0,s.Q5)(e,d.shape,d.dtype,b,n);g=t.makeTensorInfo(n,d.dtype),t.texData.get(g.dataId).values=a}else g=(0,i._)(d,b,t);m=a.backend_util.getInnerMostAxes(m.length,u)}a.backend_util.assertAxesAreInnerMostDims("max",m,u);const[I,x]=a.backend_util.computeOutAndReduceShapes(g.shape,m);let N,v=I;if(c&&(v=a.backend_util.expandShapeToKeepDim(I,h)),f){const e=t.texData.get(g.dataId).values,n=(0,s.rw)(e,a.ZSL.sizeFromShape(x),v,d.dtype);N=t.makeTensorInfo(v,d.dtype),t.texData.get(N.dataId).values=n}else N=function(e,n,t,s){const i=a.ZSL.sizeFromShape(n),p=a.ZSL.sizeFromShape(e.shape)/i,d=(0,o.t)({inputs:{x:e},attrs:{shape:[p,i]},backend:s}),l=(0,r.T)(d,e.dtype,"max",s),c=(0,o.t)({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(l),c}(g,x,v,t);return k&&t.disposeIntermediateTensorInfo(g),N}const d={kernelName:a.VAI,backendName:"webgl",kernelFunc:p}},18801:(e,n,t)=>{t.d(n,{$:()=>i});var a=t(36115),s=t(80297),r=t(88380),o=t(77723);const i={kernelName:a.t3d,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n;(0,r.CE)(p,"maxPool");const{filterSize:d,strides:l,pad:c,dimRoundingMode:u}=i;a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(l,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`));const h=a.backend_util.computePool2DInfo(p.shape,d,l,1,c,u);if(1===h.filterWidth&&1===h.filterHeight&&a.ZSL.arraysEqual(h.inShape,h.outShape))return(0,o.D)({inputs:{x:p},backend:t});const m=new s.h(h,"max",!1);return t.runWebGLProgram(m,[p],p.dtype)}}},92914:(e,n,t)=>{t.d(n,{A:()=>r});var a=t(36115),s=t(80297);const r={kernelName:a.ySp,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{filterSize:i,strides:p,pad:d,dataFormat:l,dimRoundingMode:c}=r,u=a.backend_util.computePool3DInfo(o.shape,i,p,[1,1,1],d,c,l),h=new s.U(u,"max",!1);return t.runWebGLProgram(h,[o],o.dtype)}}},65886:(e,n,t)=>{t.d(n,{S:()=>o});var a=t(36115),s=t(81017),r=t(80297);const o={kernelName:a.cHb,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{dy:i,input:p}=n,d=p,{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=o,m=a.backend_util.computePool3DInfo(d.shape,l,c,[1,1,1],u,h),b=new r.U(m,"max",!0),k=t.runWebGLProgram(b,[d],d.dtype),f=new s.Y(m),g=t.runWebGLProgram(f,[i,k],d.dtype);return t.disposeIntermediateTensorInfo(k),g}}},17249:(e,n,t)=>{t.d(n,{P:()=>i});var a=t(36115),s=t(81017),r=t(80297),o=t(88380);const i={kernelName:a.RXX,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{dy:p,input:d,output:l}=n,c=d;(0,o.CE)([d,l],"maxPoolGrad");const{filterSize:u,strides:h,pad:m,dimRoundingMode:b}=i,k=a.backend_util.computePool2DInfo(c.shape,u,h,1,m,b),f=new r.h(k,"max",!0),g=t.runWebGLProgram(f,[c],c.dtype),I=new s.d(k),x=t.runWebGLProgram(I,[p,g],c.dtype);return t.disposeIntermediateTensorInfo(g),x}}},38717:(e,n,t)=>{t.d(n,{l:()=>r});var a=t(36115),s=t(80297);const r={kernelName:a.TL8,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{x:r}=e,{filterSize:o,strides:i,pad:p,includeBatchInIndex:d}=n,l=t;a.ZSL.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const u=a.backend_util.computePool2DInfo(r.shape,o,i,c,p),[h,m]=function(e,n,t,a){let r=new s.h(t,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new s.h(t,"max",!0,!0,n),[o,a.runWebGLProgram(r,[e],"float32")]}(r,d,u,l);return[h,m]}}},23007:(e,n,t)=>{t.d(n,{l:()=>c});var a=t(36115),s=t(22897),r=t(46334),o=t(15411),i=t(76905);const p=s.dR+"\n  return max(a, b);\n",d="\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+r.qq+"\n  return result;\n",l=(0,o.j0)({opSnippet:p,packedOpSnippet:d,cpuKernelImpl:i.Dy}),c={kernelName:a.LDN,backendName:"webgl",kernelFunc:l}},52132:(e,n,t)=>{t.d(n,{M:()=>p});var a=t(36115),s=t(68754),r=t(43008),o=t(76905),i=t(89523);const p={kernelName:a.g5A,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{x:p}=e,{keepDims:d,axis:l}=n,c=t,u=p.shape.length,h=a.ZSL.parseAxisParam(l,p.shape);let m=h;const b=a.backend_util.getAxesPermutation(m,u),k=null!=b,f=c.shouldExecuteOnCPU([p]),g=[];let I=p;if(k){if(f){const e=c.texData.get(I.dataId).values,n=new Array(u);for(let e=0;e<n.length;e++)n[e]=p.shape[b[e]];const t=(0,o.Q5)(e,p.shape,p.dtype,b,n);I=c.makeTensorInfo(n,p.dtype),c.texData.get(I.dataId).values=t}else I=(0,i._)(p,b,c);g.push(I),m=a.backend_util.getInnerMostAxes(m.length,u)}a.backend_util.assertAxesAreInnerMostDims("sum",m,u);const[x,N]=a.backend_util.computeOutAndReduceShapes(I.shape,m);let v=x;d&&(v=a.backend_util.expandShapeToKeepDim(x,h));const S=function(e,n,t,o){const i=a.ZSL.sizeFromShape(n),p=a.ZSL.sizeFromShape(e.shape)/i,d=(0,r.t)({inputs:{x:e},attrs:{shape:[p,i]},backend:o}),l=(0,s.T)(d,"float32","mean",o),c=(0,r.t)({inputs:{x:l},attrs:{shape:t},backend:o});return o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(l),c}(I,N,v,c);for(const e of g)c.disposeIntermediateTensorInfo(e);return S}}},69941:(e,n,t)=>{t.d(n,{j:()=>i});var a=t(36115),s=t(68754),r=t(43008),o=t(58246);const i={kernelName:a.lNG,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{axis:d,keepDims:l}=i,c=p.shape.length,u=a.ZSL.parseAxisParam(d,p.shape);let h=u;const m=a.backend_util.getAxesPermutation(h,c);let b=p;null!=m&&(b=(0,o.m)({inputs:{x:p},backend:t,attrs:{perm:m}}),h=a.backend_util.getInnerMostAxes(h.length,p.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",h,c);const[k,f]=a.backend_util.computeOutAndReduceShapes(b.shape,h),g=a.ZSL.sizeFromShape(f),I=(0,r.t)({inputs:{x:b},backend:t,attrs:{shape:[-1,g]}}),x=(0,s.T)(I,I.dtype,"min",t);let N;if(l){const e=a.backend_util.expandShapeToKeepDim(k,u);N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:e}})}else N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:k}});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(x),null!=m&&t.disposeIntermediateTensorInfo(b),N}}},25621:(e,n,t)=>{t.d(n,{N:()=>c});var a=t(36115),s=t(22897),r=t(46334),o=t(15411),i=t(76905);const p=s.dR+"\n  return min(a, b);\n",d="\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+r.qq+"\n  return result;\n",l=(0,o.j0)({opSnippet:p,packedOpSnippet:d,cpuKernelImpl:i.h}),c={kernelName:a.LG0,backendName:"webgl",kernelFunc:l}},94449:(e,n,t)=>{t.d(n,{V:()=>o});var a=t(36115),s=t(51554),r=t(2171);const o={kernelName:a.x7F,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:o}=e,{paddings:i,mode:p}=t,d=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new r.V(o.shape,i,p):new s.X(o.shape,i,p);return n.runWebGLProgram(d,[o],o.dtype)}}},19013:(e,n,t)=>{t.d(n,{X:()=>p});var a=t(36115),s=t(46334),r=t(15411);const o="\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+s.qq+"\n  return result;\n",i=(0,r.j0)({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:o}),p={kernelName:a.BLA,backendName:"webgl",kernelFunc:i}},89488:(e,n,t)=>{t.d(n,{a:()=>o});var a=t(36115),s=t(26608),r=t(62667);const o={kernelName:a.WT3,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{logits:o}=n,{numSamples:i,seed:p,normalized:d}=a,l=d?o:(0,r.V)({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new s.O(c,u,i),m=[[p]],b=t.runWebGLProgram(h,[l],"int32",m);return d||t.disposeIntermediateTensorInfo(l),b}}},26041:(e,n,t)=>{t.d(n,{l:()=>l,t:()=>c});var a=t(36115),s=t(65274),r=t(22897),o=t(46334),i=t(76905),p=t(8993);const d="return a * b;";function l(e){const{inputs:n,backend:t}=e,{a:l,b:c}=n,u=a.backend_util.upcastType(l.dtype,c.dtype);if("complex64"===l.dtype){const e=t.texData.get(l.dataId),n=t.texData.get(c.dataId),a=new s.f(s.C.REAL,l.shape,c.shape),r=new s.f(s.C.IMAG,l.shape,c.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:l.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:l.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:c.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:c.shape}],i=t.runWebGLProgram(a,o,"float32"),d=t.runWebGLProgram(r,o,"float32"),u=(0,p.f)({inputs:{real:i,imag:d},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(d),u}if(t.shouldExecuteOnCPU([l,c])){const e=t.texData.get(l.dataId),n=t.texData.get(c.dataId),[a,s]=(0,i.Xe)(l.shape,c.shape,e.values,n.values,u),r=t.makeTensorInfo(s,u);return t.texData.get(r.dataId).values=a,r}let h;return h=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new o.VI(d,l.shape,c.shape):new r.x(d,l.shape,c.shape),t.runWebGLProgram(h,[l,c],u)}const c={kernelName:a.xu7,backendName:"webgl",kernelFunc:l}},40279:(e,n,t)=>{t.d(n,{h:()=>p});var a=t(36115),s=t(76905),r=t(68173),o=t(74890);const i=r.dR+"\n  return -x;\n",p={kernelName:a.l0G,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{x:p}=n;if(t.shouldExecuteOnCPU([p])){const e=t.texData.get(p.dataId),[n,a]=(0,s.rQ)(e.values,p.shape,p.dtype);return t.makeTensorInfo(a,p.dtype,n)}let d;return d=(0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new o.rf(p.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new r.hE(p.shape,i),t.runWebGLProgram(d,[p],p.dtype)}}},73816:(e,n,t)=>{t.d(n,{m:()=>r});var a=t(36115);const s=a.kpo.c7,r={kernelName:a.SDM,backendName:"webgl",kernelFunc:function(e){a.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:i}=n,{maxOutputSize:p,iouThreshold:d,scoreThreshold:l}=r,c=t.readSync(o.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=s(c,u,p,d,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}}},14669:(e,n,t)=>{t.d(n,{F:()=>r});var a=t(36115);const s=a.kpo.ZS,r={kernelName:a.Zl4,backendName:"webgl",kernelFunc:function(e){a.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:i}=n,{maxOutputSize:p,iouThreshold:d,scoreThreshold:l,padToMaxOutputSize:c}=r,u=t.readSync(o.dataId),h=t.readSync(i.dataId),{selectedIndices:m,validOutputs:b}=s(u,h,p,d,l,c);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([b]))]}}},70318:(e,n,t)=>{t.d(n,{u:()=>r});var a=t(36115);const s=a.kpo.ut,r={kernelName:a.e0f,backendName:"webgl",kernelFunc:function(e){a.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:i}=n,{maxOutputSize:p,iouThreshold:d,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(o.dataId),h=t.readSync(i.dataId),m=p,b=d,k=l,f=c,{selectedIndices:g,selectedScores:I}=s(u,h,m,b,k,f);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([I.length],"float32",new Float32Array(I))]}}},98890:(e,n,t)=>{t.d(n,{A:()=>i,E:()=>o});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.j0)({opSnippet:"return float(a != b);",cpuKernelImpl:r.ad,dtype:"bool"}),i={kernelName:a.ylV,backendName:"webgl",kernelFunc:o}},62642:(e,n,t)=>{t.d(n,{_:()=>o});var a=t(36115),s=t(94804),r=t(43008);const o={kernelName:a.urI,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:o}=e,{indices:i}=n,{dtype:p,depth:d,onValue:l,offValue:c}=o,u=a.ZSL.sizeFromShape(i.shape),h=new s.M(u,d,l,c),m=(0,r.t)({inputs:{x:i},backend:t,attrs:{shape:[u]}}),b=t.runWebGLProgram(h,[m],p);t.disposeIntermediateTensorInfo(m);const k=[...i.shape,d],f=(0,r.t)({inputs:{x:b},backend:t,attrs:{shape:k}});return t.disposeIntermediateTensorInfo(b),f}}},64635:(e,n,t)=>{t.d(n,{h:()=>d});var a=t(36115),s=t(8993),r=t(37664),o=t(39803),i=t(4313),p=t(30097);const d={kernelName:a.LWX,backendName:"webgl",kernelFunc:function e(n){const{inputs:t,backend:a}=n,{x:d}=t;if("string"===d.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===d.dtype){const n=(0,i.x)({inputs:{input:d},backend:a}),t=e({inputs:{x:n},backend:a}),r=(0,o.n)({inputs:{input:d},backend:a}),l=(0,p.P)({inputs:{x:r},backend:a}),c=(0,s.f)({inputs:{real:t,imag:l},backend:a});return a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(l),c}return(0,r.G)({attrs:{shape:d.shape,dtype:d.dtype,value:1},backend:a})}}},54532:(e,n,t)=>{t.d(n,{q:()=>o});var a=t(36115),s=t(93179),r=t(98134);const o={kernelName:a.mM$,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{axis:i}=o;if(1===n.length)return(0,r.U)({inputs:{input:n[0]},backend:t,attrs:{dim:i}});const p=n[0].shape,d=n[0].dtype;n.forEach((e=>{a.ZSL.assertShapesMatch(p,e.shape,"All tensors passed to stack must have matching shapes"),a.ZSL.assert(d===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const l=[],c=n.map((e=>{const n=(0,r.U)({inputs:{input:e},backend:t,attrs:{dim:i}});return l.push(n),n})),u=(0,s.x)({inputs:c,backend:t,attrs:{axis:i}});return l.forEach((e=>t.disposeIntermediateTensorInfo(e))),u}}},92616:(e,n,t)=>{t.d(n,{e:()=>p,w:()=>i});var a=t(36115),s=t(59344),r=t(11601),o=t(37664);const i=e=>{const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{paddings:d,constantValue:l}=i;if(0===a.ZSL.sizeFromShape(p.shape)){const e=d.map(((e,n)=>e[0]+p.shape[n]+e[1]));return(0,o.G)({backend:t,attrs:{shape:e,value:l,dtype:p.dtype}})}const c=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new r._(p.shape,d,l):new s.e(p.shape,d,l),u=[[l]];return t.runWebGLProgram(c,[p],p.dtype,u)},p={kernelName:a.ODT,backendName:"webgl",kernelFunc:i}},48223:(e,n,t)=>{t.d(n,{j:()=>p});var a=t(36115),s=t(46334),r=t(15411);const o="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+s.qq+"\n  return result;\n",i=(0,r.j0)({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:o}),p={kernelName:a.pyJ,backendName:"webgl",kernelFunc:i}},14899:(e,n,t)=>{t.d(n,{CN:()=>i,DH:()=>o,HK:()=>p});var a=t(36115),s=t(22897),r=t(46334);const o="return (a < 0.) ? b * a : a;",i="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",p={kernelName:a.Ncv,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{x:p,alpha:d}=n,l=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new r.VI(i,p.shape,d.shape):new s.x(o,p.shape,d.shape);return t.runWebGLProgram(l,[p,d],"float32")}}},74952:(e,n,t)=>{t.d(n,{S:()=>p});var a=t(36115),s=t(68754),r=t(76905),o=t(43008),i=t(58246);const p={kernelName:a.kdj,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:p}=e,{x:d}=n,{axis:l,keepDims:c}=p,u=d.shape.length,h=[],m=a.ZSL.parseAxisParam(l,d.shape);let b=m;const k=a.backend_util.getAxesPermutation(b,u);let f,g=d;if(null!=k&&(g=(0,i.m)({inputs:{x:d},backend:t,attrs:{perm:k}}),b=a.backend_util.getInnerMostAxes(b.length,u),h.push(g)),a.backend_util.assertAxesAreInnerMostDims("prod",b,u),t.shouldExecuteOnCPU([g])){const e=t.texData.get(g.dataId).values,{outVals:n,outShape:a,outDtype:s}=(0,r.Og)(g.shape,g.dtype,e,b);f=t.makeTensorInfo(a,s,n)}else{const[e,n]=a.backend_util.computeOutAndReduceShapes(g.shape,b),r=a.ZSL.sizeFromShape(n),i=(0,o.t)({inputs:{x:g},backend:t,attrs:{shape:[-1,r]}}),p=(0,a.chL)(d.dtype),l=(0,s.T)(i,p,"prod",t);f=(0,o.t)({inputs:{x:l},backend:t,attrs:{shape:e}}),h.push(i),h.push(l)}if(c){h.push(f);const e=a.backend_util.expandShapeToKeepDim(f.shape,m);f=(0,o.t)({inputs:{x:f},backend:t,attrs:{shape:e}})}return h.forEach((e=>t.disposeIntermediateTensorInfo(e))),f}}},73008:(e,n,t)=>{t.d(n,{i:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.oJ2,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=n,{outputRaggedRank:p}=a,d=r.map((e=>t.readSync(e.dataId))),l=r.map((e=>e.shape)),c=t.readSync(o.dataId),u=t.readSync(i.dataId),[h,m,b]=(0,s.G4)(d,l,c,o.shape,o.dtype,u,i.shape,p),k=h.map((e=>t.makeTensorInfo([e.length],"int32",e))),f=t.makeTensorInfo(b,o.dtype,m);return k.concat([f])}}},53874:(e,n,t)=>{t.d(n,{Y:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.CQC,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{starts:a,limits:r,deltas:o}=n,i=t.readSync(a.dataId),p=t.readSync(r.dataId),d=t.readSync(o.dataId),[l,c]=(0,s.Oy)(i,a.shape,a.dtype,p,r.shape,d,o.shape);return[t.makeTensorInfo([l.length],"int32",l),t.makeTensorInfo([c.length],a.dtype,c)]}}},67926:(e,n,t)=>{t.d(n,{g:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.mH5,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{shape:r,values:o,defaultValue:i,rowPartitionTensors:p}=n,{rowPartitionTypes:d}=a,l=t.readSync(r.dataId),c=t.readSync(o.dataId),u=t.readSync(i.dataId),h=p.map((e=>t.readSync(e.dataId))),m=p.map((e=>e.shape)),[b,k]=(0,s.G3)(l,r.shape,c,o.shape,o.dtype,u,i.shape,h,m,d);return t.makeTensorInfo(b,o.dtype,k)}}},39264:(e,n,t)=>{t.d(n,{i:()=>o,y:()=>r});var a=t(36115),s=t(76905);const r=e=>{const{backend:n,attrs:t}=e,{start:a,stop:r,step:o,dtype:i}=t,p=(0,s.we)(a,r,o,i);return n.makeTensorInfo([p.length],i,p)},o={kernelName:a.Q6t,backendName:"webgl",kernelFunc:r}},4313:(e,n,t)=>{t.d(n,{r:()=>o,x:()=>r});var a=t(36115),s=t(77723);function r(e){const{inputs:n,backend:t}=e,{input:a}=n,r=t.texData.get(a.dataId);return(0,s.D)({inputs:{x:r.complexTensorInfos.real},backend:t})}const o={kernelName:a.LRy,backendName:"webgl",kernelFunc:r}},4490:(e,n,t)=>{t.d(n,{G:()=>r,M:()=>s});var a=t(36115);const s=(0,t(15411).j0)({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),r={kernelName:a.sDr,backendName:"webgl",kernelFunc:s}},49649:(e,n,t)=>{t.d(n,{l:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return 1.0 / x;"}),r={kernelName:a.huO,backendName:"webgl",kernelFunc:s}},37647:(e,n,t)=>{t.d(n,{z:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  return (x < 0.0) ? 0.0 : x;\n",o=(0,s.vi)({opSnippet:r,packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),i={kernelName:a.fUj,backendName:"webgl",kernelFunc:o}},14421:(e,n,t)=>{t.d(n,{X:()=>i});var a=t(36115),s=t(15411);const r=t(68173).dR+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",o=(0,s.vi)({opSnippet:r,packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),i={kernelName:a.P_L,backendName:"webgl",kernelFunc:o}},43008:(e,n,t)=>{t.d(n,{t:()=>o,V:()=>i});var a=t(36115),s=t(1404),r=t(88380);function o(e){const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{shape:p}=o,d=t,l=a.ZSL.sizeFromShape(i.shape),c=a.ZSL.inferFromImplicitShape(p,l),u=a.ZSL.sizeFromShape(c);a.ZSL.assert(l===u,(()=>`The new shape (${c}) has ${u} elements and the old shape (${i.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`));const h=d.texData.get(i.dataId);return!h.isPacked||(0,r.P0)(i.shape,c)||null!==h.texture&&(0,r.P0)(h.shape,c)?(d.incRef(i.dataId),{dataId:i.dataId,shape:c,dtype:i.dtype}):function(e,n,t){const a=[(0,r.N0)(e.shape),...(0,r.Ph)(e.shape)],o={dtype:e.dtype,shape:a,dataId:e.dataId},i=[(0,r.N0)(n),...(0,r.Ph)(n)],p=new s.R(i,a),d=[a],l=t.runWebGLProgram(p,[o],e.dtype,d,!0);return{dataId:l.dataId,shape:n,dtype:l.dtype}}(i,c,d)}const i={kernelName:a.R23,backendName:"webgl",kernelFunc:o}},2249:(e,n,t)=>{t.d(n,{T:()=>o});var a=t(36115),s=t(26180),r=t(16853);const o={kernelName:a.hgw,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{images:i}=n,{alignCorners:p,halfPixelCenters:d,size:l}=o,[c,u]=l,h=(0,a._K2)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new r.x(i.shape,c,u,p,d):new s.z(i.shape,c,u,p,d);return t.runWebGLProgram(h,[i],"float32")}}},68889:(e,n,t)=>{t.d(n,{j:()=>r});var a=t(36115),s=t(47791);const r={kernelName:a.FCQ,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{images:r,dy:o}=n,{alignCorners:i}=a,p=new s.h(o.shape,r.shape,i);return t.runWebGLProgram(p,[o],o.dtype)}}},43137:(e,n,t)=>{t.d(n,{j:()=>o});var a=t(36115),s=t(6917),r=t(59250);const o={kernelName:a.jOE,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{images:i}=n,{alignCorners:p,halfPixelCenters:d,size:l}=o,[c,u]=l,h=(0,a._K2)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new r.z(i.shape,c,u,p,d):new s.$(i.shape,c,u,p,d);return t.runWebGLProgram(h,[i],i.dtype)}}},96017:(e,n,t)=>{t.d(n,{n:()=>r});var a=t(36115),s=t(27436);const r={kernelName:a.XQy,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{images:r,dy:o}=n,{alignCorners:i}=a,p=new s.x(o.shape,r.shape,i);return t.runWebGLProgram(p,[o],o.dtype)}}},86567:(e,n,t)=>{t.d(n,{r:()=>i});var a=t(36115),s=t(71967),r=t(68636),o=t(77723);const i={kernelName:a.D7i,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{dims:d}=i,l=p.shape.length,c=a.ZSL.parseAxisParam(d,p.shape);if(0===l)return(0,o.D)({inputs:{x:p},backend:t});const u=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new r.X(p.shape,c):new s.N(p.shape,c);return t.runWebGLProgram(u,[p],p.dtype)}}},24929:(e,n,t)=>{t.d(n,{f:()=>r});var a=t(36115),s=t(40784);const r={kernelName:a.BK4,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{image:r}=e,{radians:o,fillValue:i,center:p}=n,d=t,l=new s.e(r.shape,i),[c,u]=a.backend_util.getImageCenter(p,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(o),Math.cos(o)]];return d.runWebGLProgram(l,[r],r.dtype,h)}}},84745:(e,n,t)=>{t.d(n,{$:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),r={kernelName:a.hVg,backendName:"webgl",kernelFunc:s}},34733:(e,n,t)=>{t.d(n,{L:()=>i});var a=t(36115),s=t(15411),r=t(76905);const o=(0,s.vi)({opSnippet:"return inversesqrt(x);",cpuKernelImpl:r.tc}),i={kernelName:a.TOR,backendName:"webgl",kernelFunc:o}},35137:(e,n,t)=>{t.d(n,{H:()=>o});var a=t(36115),s=t(8939),r=t(43008);const o={kernelName:a.pJc,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{indices:i,updates:p}=n,{shape:d}=o,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:m}=a.backend_util.calculateShapes(p,i,d),b=[m/u,u];if(0===m)return t.makeTensorInfo(d,i.dtype);const k=(0,r.t)({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),f=(0,r.t)({inputs:{x:p},backend:t,attrs:{shape:[c,u]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0])),I=new s.$(c,l,k.shape.length,f.shape.length,h,b),x=t.runWebGLProgram(I,[f,k,g],f.dtype),N=(0,r.t)({inputs:{x},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(g),N}}},33556:(e,n,t)=>{t.d(n,{M:()=>r});var a=t(36115),s=t(473);const r={kernelName:a.uWl,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{sortedSequence:r,values:o}=n,{side:i}=a,p=new s.i(r.shape[0],r.shape[1],o.shape[1],i),d=[[r.shape[1]]];return t.runWebGLProgram(p,[r,o],"int32",d)}}},51361:(e,n,t)=>{t.d(n,{z:()=>r});var a=t(36115),s=t(81847);const r={kernelName:a.l6P,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{condition:r,t:o,e:i}=n,p=new s.T(r.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(p,[r,o,i],(0,a.TuY)(o.dtype,i.dtype))}}},64770:(e,n,t)=>{t.d(n,{k:()=>i});var a=t(36115),s=t(15411);const r=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${a.backend_util.SELU_SCALEALPHA};\n  float scale = ${a.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,o=(0,s.vi)({opSnippet:r}),i={kernelName:a.u$b,backendName:"webgl",kernelFunc:o}},24129:(e,n,t)=>{t.d(n,{X:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o=s.Zt+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",i=(0,s.vi)({opSnippet:o,packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:r.BC}),p={kernelName:a.vI1,backendName:"webgl",kernelFunc:i}},43168:(e,n,t)=>{t.d(n,{C:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),r={kernelName:a.YVe,backendName:"webgl",kernelFunc:s}},60739:(e,n,t)=>{t.d(n,{b:()=>i});var a=t(36115),s=t(15411);const r=s.Zt+"\n  return sin(x);\n",o=(0,s.vi)({opSnippet:r}),i={kernelName:a.hql,backendName:"webgl",kernelFunc:o}},49627:(e,n,t)=>{t.d(n,{$:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),r={kernelName:a.J3C,backendName:"webgl",kernelFunc:s}},29547:(e,n,t)=>{t.d(n,{d:()=>i,l:()=>p});var a=t(36115),s=t(76905),r=t(10043),o=t(5144);function i(e){const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{begin:d,size:l}=i,[c,u]=a.Kro.parseSliceParams(p,d,l);if(a.Kro.assertParamsValid(p,c,u),0===a.ZSL.sizeFromShape(u))return t.makeTensorInfo(u,p.dtype,[]);if(t.shouldExecuteOnCPU([p])||"string"===p.dtype){const e=t.texData.get(p.dataId),n=(0,s.J3)(e.values,c,u,p.shape,p.dtype);return t.makeTensorInfo(u,p.dtype,n)}const{isPacked:h}=t.texData.get(p.dataId),m=a.Kro.isSliceContinous(p.shape,c,u);if(h||!m){const e=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new o.V(u):new r.J(u),n=[c];return t.runWebGLProgram(e,[p],p.dtype,n)}return t.uploadToGPU(p.dataId),function(e,n,t,s){const r=s.texData.get(e.dataId),o=s.makeTensorInfo(t,e.dtype),i=s.texData.get(o.dataId);Object.assign(i,r),i.refCount=1,i.shape=t,i.dtype=e.dtype;let p=a.Kro.computeFlatOffset(n,a.ZSL.computeStrides(e.shape));r.slice&&(p+=r.slice.flatOffset),i.slice={flatOffset:p,origDataId:r.slice&&r.slice.origDataId||e.dataId};const d=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,d+1),o}(p,c,u,t)}const p={kernelName:a.JiE,backendName:"webgl",kernelFunc:i}},62667:(e,n,t)=>{t.d(n,{$:()=>c,V:()=>l});var a=t(36115),s=t(29450),r=t(99160),o=t(4490),i=t(43008),p=t(38483),d=t(22853);function l(e){const{inputs:n,backend:t,attrs:l}=e,{logits:c}=n,{dim:u}=l,h=a.ZSL.parseAxisParam([u],c.shape),m=(0,r.T)({inputs:{x:c},backend:t,attrs:{reductionIndices:h,keepDims:!1}}),b=a.backend_util.expandShapeToKeepDim(m.shape,h),k=(0,i.t)({inputs:{x:m},backend:t,attrs:{shape:b}}),f=(0,p.j)({inputs:{a:c,b:k},backend:t}),g=(0,s.oN)({inputs:{x:f},backend:t}),I=(0,d.c)({inputs:{x:g},backend:t,attrs:{axis:h,keepDims:!1}}),x=(0,i.t)({inputs:{x:I},backend:t,attrs:{shape:b}}),N=(0,o.M)({inputs:{a:g,b:x},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(x),N}const c={kernelName:a.rFG,backendName:"webgl",kernelFunc:l}},68065:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),r={kernelName:a.Fin,backendName:"webgl",kernelFunc:s}},50894:(e,n,t)=>{t.d(n,{W:()=>i});var a=t(36115),s=t(92616),r=t(43008),o=t(58246);const i={kernelName:a.A8B,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:i}=e,{x:p}=n,{blockShape:d,paddings:l}=i;a.ZSL.assert(p.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const c=d.reduce(((e,n)=>e*n)),u=[[0,0]];u.push(...l);for(let e=1+d.length;e<p.shape.length;++e)u.push([0,0]);const h=[],m=(0,s.w)({inputs:{x:p},backend:t,attrs:{paddings:u,constantValue:0}}),b=a.backend_util.getReshaped(m.shape,d,c,!1),k=a.backend_util.getPermuted(b.length,d.length,!1),f=a.backend_util.getReshapedPermuted(m.shape,d,c,!1),g=(0,r.t)({inputs:{x:m},backend:t,attrs:{shape:b}}),I=(0,o.m)({inputs:{x:g},backend:t,attrs:{perm:k}}),x=(0,r.t)({inputs:{x:I},backend:t,attrs:{shape:f}});return h.push(m),h.push(g),h.push(I),h.forEach((e=>t.disposeIntermediateTensorInfo(e))),x}}},49442:(e,n,t)=>{t.d(n,{K:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.C8s,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{indices:a,values:r,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const p=t.readSync(a.dataId),d=t.readSync(r.dataId),l=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[u,h,m,b,k]=(0,s.sB)(p,a.shape,a.dtype,d,r.dtype,l,c);return[t.makeTensorInfo(h,a.dtype,u),t.makeTensorInfo([h[0]],r.dtype,m),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map((e=>Number(e))))),t.makeTensorInfo([k.length],a.dtype,new Int32Array(k))]}}},25103:(e,n,t)=>{t.d(n,{F:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.BoJ,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{inputIndices:a,inputShape:r,newShape:o}=n;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(r.dataId)),p=t.readSync(a.dataId),d=Array.from(t.readSync(o.dataId)),[l,c,u]=(0,s.vo)(p,a.shape,a.dtype,i,d);return[t.makeTensorInfo(c,a.dtype,l),t.makeTensorInfo([u.length],o.dtype,new Int32Array(u))]}}},58137:(e,n,t)=>{t.d(n,{v:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.L6G,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{data:a,indices:r,segmentIds:o}=n;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=t.readSync(a.dataId),p=t.readSync(r.dataId),d=t.readSync(o.dataId),[l,c]=(0,s.zN)(i,a.shape,a.dtype,p,d,!0);return t.makeTensorInfo(c,a.dtype,l)}}},40257:(e,n,t)=>{t.d(n,{j:()=>r});var a=t(36115),s=t(76905);const r={kernelName:a.DvZ,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{data:a,indices:r,segmentIds:o}=n;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=t.readSync(a.dataId),p=t.readSync(r.dataId),d=t.readSync(o.dataId),[l,c]=(0,s.zN)(i,a.shape,a.dtype,p,d);return t.makeTensorInfo(c,a.dtype,l)}}},80809:(e,n,t)=>{t.d(n,{x:()=>i});var a=t(36115),s=t(76905),r=t(8939),o=t(43008);const i={kernelName:a.jgd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:i}=e,{sparseIndices:p,sparseValues:d,defaultValue:l}=n,{outputShape:c}=i,{sliceRank:u,numUpdates:h,sliceSize:m,strides:b,outputSize:k}=a.backend_util.calculateShapes(d,p,c);if("string"===d.dtype){const e=t.bufferSync(p),n=t.bufferSync(d),r=a.ZSL.decodeString(t.readSync(l.dataId)[0]),o=(0,s.fC)(e,n,c,k,m,h,u,b,r,!1);return t.makeTensorInfo(c,o.dtype,o.values)}const f=new r.$(h,u,p.shape.length,d.shape.length,b,[k,1],!1),g=t.runWebGLProgram(f,[d,p,l],d.dtype),I=(0,o.t)({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(g),I}}},63575:(e,n,t)=>{t.d(n,{t:()=>r});var a=t(36115),s=t(29547);const r={kernelName:a.Blb,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{numOrSizeSplits:i,axis:p}=r,d=a.ZSL.parseAxisParam(p,o.shape)[0],l=a.backend_util.prepareSplitSize(o,i,d),c=o.shape.length,u=new Array(c).fill(0),h=o.shape.slice();return l.map((e=>{const n=[...h];n[d]=e;const a=(0,s.d)({inputs:{x:o},backend:t,attrs:{begin:u,size:n}});return u[d]+=e,a}))}}},5643:(e,n,t)=>{t.d(n,{F:()=>p});var a=t(36115),s=t(15411),r=t(76905);const o="return sqrt(x);",i=(0,s.vi)({opSnippet:o,packedOpSnippet:o,cpuKernelImpl:r.LF}),p={kernelName:a.dFH,backendName:"webgl",kernelFunc:i}},12030:(e,n,t)=>{t.d(n,{e:()=>r});var a=t(36115);const s=(0,t(15411).vi)({opSnippet:"return x * x;"}),r={kernelName:a.M6A,backendName:"webgl",kernelFunc:s}},55571:(e,n,t)=>{t.d(n,{b:()=>o});var a=t(36115);const s="return (a - b) * (a - b);",r=(0,t(15411).j0)({opSnippet:s,packedOpSnippet:s}),o={kernelName:a.Ddj,backendName:"webgl",kernelFunc:r}}}]);